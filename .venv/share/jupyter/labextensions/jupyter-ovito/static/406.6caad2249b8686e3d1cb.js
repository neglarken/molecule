(self.webpackChunkjupyter_ovito=self.webpackChunkjupyter_ovito||[]).push([[406],{1568:(e,n,t)=>{e.exports=t(1190),e.exports.version=t(4147).version},8657:(e,n,t)=>{e.exports.j="^0.1.5",t(4147).version},1190:(e,n,t)=>{"use strict";t.r(n),t.d(n,{OvitoViewportModel:()=>Y,OvitoViewportView:()=>V});var i=t(1214);const o={type:"change"},r={type:"start"},a={type:"end"};class s extends i.EventDispatcher{constructor(e,n){super(),this.object=e,this.domElement=n,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new i.Vector3,this.sceneSizeFactor=1,this.zoomSpeed=.7,this.rotateSpeed=1,this.panSpeed=1,this.keyPanSpeed=7,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:i.MOUSE.ROTATE,MIDDLE:i.MOUSE.DOLLY,RIGHT:i.MOUSE.PAN},this.touches={ONE:i.TOUCH.ROTATE,TWO:i.TOUCH.DOLLY_PAN},this._domElementKeyEvents=null,this.setObject=function(e){t.object=e},this.listenToKeyEvents=function(e){e.addEventListener("keydown",H),this._domElementKeyEvents=e},this.saveState=function(){t.object&&(t.oldMatrix=t.object.matrix.clone(),t.oldMatrixInverse=t.oldMatrix.clone().invert(),t.oldZoom=t.object.zoom)},this.updateSceneSizeFactor=function(e){if(console.assert(!0===e.isBox3),e.isEmpty())t.sceneSizeFactor=1;else{const n=e.getSize(new i.Vector3).length();t.sceneSizeFactor=.0025*n}},this.update=function(){const e=new i.Vector3,n=new i.Vector3;return function(){if(!t.object)return!1;if(e.setFromMatrixPosition(t.oldMatrix),e.add(h),t.object.isPerspectiveCamera&&0!=d){const i=t.sceneSizeFactor*d;n.setFromMatrixColumn(t.oldMatrix,2).normalize(),e.addScaledVector(n,i)}t.object.matrix.copy(t.oldMatrix).setPosition(e);const r=t.object.up.clone().transformDirection(t.oldMatrixInverse);let a,s;a=0==r.x&&0==r.y?Math.PI:Math.atan2(r.x,r.y),s=Math.atan2(Math.sqrt(r.x*r.x+r.y*r.y),r.z);let c=l.phi,f=l.theta;if(s+c<1e-6?c=1e-6-s:s+c>Math.PI-1e-6&&(c=Math.PI-1e-6-s),0!=c||0!=f){const e=t.target,n=e.clone().applyMatrix4(t.oldMatrixInverse),o=(new i.Matrix4).setPosition(e),r=(new i.Matrix4).makeRotationAxis(t.object.up,-f),a=(new i.Matrix4).makeTranslation(-e.x,-e.y,-e.z),s=t.oldMatrix,l=(new i.Matrix4).setPosition(n),d=(new i.Matrix4).makeRotationX(c),h=(new i.Matrix4).makeTranslation(-n.x,-n.y,-n.z);o.multiply(r),o.multiply(a),o.multiply(s),o.multiply(l),o.multiply(d),o.multiply(h),t.object.matrix.copy(o)}t.object.updateMatrixWorld(!0),t.dispatchEvent(o)}}(),this.dispose=function(){t.domElement.removeEventListener("contextmenu",k),t.domElement.removeEventListener("pointerdown",V),t.domElement.removeEventListener("pointercancel",U),t.domElement.removeEventListener("wheel",W),t.domElement.removeEventListener("pointermove",R),t.domElement.removeEventListener("pointerup",j),null!==t._domElementKeyEvents&&t._domElementKeyEvents.removeEventListener("keydown",H)};const t=this,s=-1;let c=s;const l=new i.Spherical;let d=0;const h=new i.Vector3,f=new i.Vector2,u=new i.Vector2,p=new i.Vector2,m=new i.Vector2,g=new i.Vector2,v=new i.Vector2,y=new i.Vector2,_=new i.Vector2,I=new i.Vector2,T=[],b={};function L(){return Math.pow(.95,t.zoomSpeed)}function w(e){l.theta+=e}function O(e){l.phi-=e}const x=function(){const e=new i.Vector3;return function(n,t){e.setFromMatrixColumn(t,0),e.multiplyScalar(-n),h.add(e)}}(),M=function(){const e=new i.Vector3;return function(n,t){e.setFromMatrixColumn(t,1),e.multiplyScalar(n),h.add(e)}}(),G=function(){const e=new i.Vector3;return function(n,i){const o=t.domElement;if(t.object.isPerspectiveCamera){e.setFromMatrixPosition(t.oldMatrix),e.sub(t.target);let r=e.length();r*=Math.tan(t.object.fov/2*Math.PI/180),x(2*n*r/o.clientHeight,t.object.matrix),M(2*i*r/o.clientHeight,t.object.matrix)}else t.object.isOrthographicCamera&&(x(n*(t.object.right-t.object.left)/t.object.zoom/o.clientWidth,t.object.matrix),M(i*(t.object.top-t.object.bottom)/t.object.zoom/o.clientHeight,t.object.matrix))}}();function C(e){t.object.isPerspectiveCamera?d+=I.y*t.zoomSpeed:t.object.isOrthographicCamera&&(t.object.zoom*=e)}function P(e){t.object.isPerspectiveCamera?d+=I.y*t.zoomSpeed:t.object.isOrthographicCamera&&(t.object.zoom/=e)}function A(e){f.set(e.clientX,e.clientY),t.saveState(),h.set(0,0,0),l.set(0,0,0),d=0}function N(e){m.set(e.clientX,e.clientY),t.saveState(),h.set(0,0,0),l.set(0,0,0),d=0}function S(){if(1===T.length)f.set(T[0].pageX,T[0].pageY);else{const e=.5*(T[0].pageX+T[1].pageX),n=.5*(T[0].pageY+T[1].pageY);f.set(e,n)}}function E(){if(1===T.length)m.set(T[0].pageX,T[0].pageY);else{const e=.5*(T[0].pageX+T[1].pageX),n=.5*(T[0].pageY+T[1].pageY);m.set(e,n)}}function D(){const e=T[0].pageX-T[1].pageX,n=T[0].pageY-T[1].pageY,t=Math.sqrt(e*e+n*n);y.set(0,t)}function F(e){if(1==T.length)u.set(e.pageX,e.pageY);else{const n=K(e),t=.5*(e.pageX+n.x),i=.5*(e.pageY+n.y);u.set(t,i)}p.subVectors(u,f).multiplyScalar(t.rotateSpeed);const n=t.domElement;w(2*Math.PI*p.x/n.clientHeight),O(2*Math.PI*p.y/n.clientHeight),f.copy(u)}function z(e){if(1===T.length)g.set(e.pageX,e.pageY);else{const n=K(e),t=.5*(e.pageX+n.x),i=.5*(e.pageY+n.y);g.set(t,i)}v.subVectors(g,m).multiplyScalar(t.panSpeed),G(v.x,v.y),m.copy(g)}function Y(e){const n=K(e),i=e.pageX-n.x,o=e.pageY-n.y,r=Math.sqrt(i*i+o*o);_.set(0,r),I.set(0,Math.pow(_.y/y.y,t.zoomSpeed)),C(I.y),y.copy(_)}function V(e){!1!==t.enabled&&(0===T.length&&(t.domElement.setPointerCapture(e.pointerId),t.domElement.addEventListener("pointermove",R),t.domElement.addEventListener("pointerup",j)),function(e){T.push(e)}(e),"touch"===e.pointerType?function(e){switch(Z(e),T.length){case 1:switch(t.touches.ONE){case i.TOUCH.ROTATE:S(),c=3;break;case i.TOUCH.PAN:E(),c=4;break;default:c=s}break;case 2:switch(t.touches.TWO){case i.TOUCH.DOLLY_PAN:D(),E(),c=5;break;case i.TOUCH.DOLLY_ROTATE:D(),S(),c=6;break;default:c=s}break;default:c=s}c!==s&&t.dispatchEvent(r)}(e):function(e){let n;switch(e.button){case 0:n=t.mouseButtons.LEFT;break;case 1:n=t.mouseButtons.MIDDLE;break;case 2:n=t.mouseButtons.RIGHT;break;default:n=-1}switch(n){case i.MOUSE.DOLLY:!function(e){y.set(e.clientX,e.clientY),t.saveState(),h.set(0,0,0),l.set(0,0,0),d=0}(e),c=1;break;case i.MOUSE.ROTATE:e.ctrlKey||e.metaKey||e.shiftKey?(N(e),c=2):(A(e),c=0);break;case i.MOUSE.PAN:e.ctrlKey||e.metaKey||e.shiftKey?(A(e),c=0):(N(e),c=2);break;default:c=s}c!==s&&t.dispatchEvent(r)}(e))}function R(e){!1!==t.enabled&&("touch"===e.pointerType?function(e){switch(Z(e),c){case 3:F(e),t.update();break;case 4:z(e),t.update();break;case 5:!function(e){Y(e),z(e)}(e),t.update();break;case 6:!function(e){Y(e),F(e)}(e),t.update();break;default:c=s}}(e):function(e){if(!1!==t.enabled)switch(c){case 0:!function(e){u.set(e.clientX,e.clientY),p.subVectors(u,f).multiplyScalar(t.rotateSpeed);const n=t.domElement;w(2*Math.PI*p.x/n.clientHeight),O(2*Math.PI*p.y/n.clientHeight),f.copy(u),t.update()}(e);break;case 1:!function(e){_.set(e.clientX,e.clientY),I.subVectors(_,y),I.y>0?C(L()):I.y<0&&P(L()),y.copy(_),t.update()}(e);break;case 2:!function(e){g.set(e.clientX,e.clientY),v.subVectors(g,m).multiplyScalar(t.panSpeed),G(v.x,v.y),m.copy(g),t.update()}(e)}}(e))}function j(e){B(e),0===T.length&&(t.domElement.releasePointerCapture(e.pointerId),t.domElement.removeEventListener("pointermove",R),t.domElement.removeEventListener("pointerup",j)),t.dispatchEvent(a),c=s}function U(e){B(e)}function W(e){!1!==t.enabled&&!1!==t.enableZoom&&c===s&&(e.preventDefault(),t.dispatchEvent(r),function(e){t.saveState(),h.set(0,0,0),l.set(0,0,0),d=0,I.y=e.deltaY,e.deltaY<0?P(L()):e.deltaY>0&&C(L()),t.update()}(e),t.dispatchEvent(a))}function H(e){!1!==t.enabled&&function(e){let n=!1;switch(e.code){case t.keys.UP:G(0,t.keyPanSpeed),n=!0;break;case t.keys.BOTTOM:G(0,-t.keyPanSpeed),n=!0;break;case t.keys.LEFT:G(t.keyPanSpeed,0),n=!0;break;case t.keys.RIGHT:G(-t.keyPanSpeed,0),n=!0}n&&(e.preventDefault(),t.update())}(e)}function k(e){!1!==t.enabled&&e.preventDefault()}function B(e){delete b[e.pointerId];for(let n=0;n<T.length;n++)if(T[n].pointerId==e.pointerId)return void T.splice(n,1)}function Z(e){let n=b[e.pointerId];void 0===n&&(n=new i.Vector2,b[e.pointerId]=n),n.set(e.pageX,e.pageY)}function K(e){const n=e.pointerId===T[0].pointerId?T[1]:T[0];return b[n.pointerId]}t.domElement.addEventListener("contextmenu",k),t.domElement.addEventListener("pointerdown",V),t.domElement.addEventListener("pointercancel",U),t.domElement.addEventListener("wheel",W,{passive:!1}),t.saveState(),t.update()}}class c{static isWebGLAvailable(){try{const e=document.createElement("canvas");return!(!window.WebGLRenderingContext||!e.getContext("webgl")&&!e.getContext("experimental-webgl"))}catch(e){return!1}}static isWebGL2Available(){try{const e=document.createElement("canvas");return!(!window.WebGL2RenderingContext||!e.getContext("webgl2"))}catch(e){return!1}}static getWebGLErrorMessage(){return this.getErrorMessage(1)}static getWebGL2ErrorMessage(){return this.getErrorMessage(2)}static getErrorMessage(e){const n={1:window.WebGLRenderingContext,2:window.WebGL2RenderingContext};let t='Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>';const i=document.createElement("div");return i.id="webglmessage",i.style.fontFamily="monospace",i.style.fontSize="13px",i.style.fontWeight="normal",i.style.textAlign="center",i.style.background="#fff",i.style.color="#000",i.style.padding="1.5em",i.style.width="400px",i.style.margin="5em auto 0",t=n[e]?t.replace("$0","graphics card"):t.replace("$0","browser"),t=t.replace("$1",{1:"WebGL",2:"WebGL 2"}[e]),i.innerHTML=t,i}}const l={zoom_all:{light:"'data:image/svg+xml;base64,LjAiIGVuY29kaW5nPSJVVEYtOCIgc3RhbmRhbG9uZT0ibm8iPz4KPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB2aWV3Qm94PSIwIDAgNTEyIDUxMiIKICAgaWQ9InN2ZzIiCiAgIHZlcnNpb249IjEuMSIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMC45Mi4yIDVjM2U4MGQsIDIwMTctMDgtMDYiCiAgIHNvZGlwb2RpOmRvY25hbWU9Inpvb21fc2NlbmVfZXh0ZW50cy5idy5zdmciPgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTEwIj4KICAgIDxyZGY6UkRGPgogICAgICA8Y2M6V29yawogICAgICAgICByZGY6YWJvdXQ9IiI+CiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+CiAgICAgICAgPGRjOnR5cGUKICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIiAvPgogICAgICA8L2NjOldvcms+CiAgICA8L3JkZjpSREY+CiAgPC9tZXRhZGF0YT4KICA8ZGVmcwogICAgIGlkPSJkZWZzOCIgLz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEiCiAgICAgb2JqZWN0dG9sZXJhbmNlPSIxMCIKICAgICBncmlkdG9sZXJhbmNlPSIxMCIKICAgICBndWlkZXRvbGVyYW5jZT0iMTAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjE0NDAiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODU1IgogICAgIGlkPSJuYW1lZHZpZXc2IgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBpbmtzY2FwZTp6b29tPSIwLjkyMTg3NSIKICAgICBpbmtzY2FwZTpjeD0iNDUuNTU5MzE4IgogICAgIGlua3NjYXBlOmN5PSIyMDUuMTY1NjUiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjAiCiAgICAgaW5rc2NhcGU6d2luZG93LXk9IjEiCiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD0iMSIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJzdmcyIiAvPgogIDxwYXRoCiAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICBkPSJNIDc0LjIzNDg4OSwxNTEuMTQzNDEgViAzNDMuNDExNzYgTCAyNzQuNjExMzMsNDMwLjUyMDkyIDQzOS45MzQ2MSwzNTguNTk4MiBWIDE1My4zMTI5IEwgMjU3LjA4NDc1LDgzLjkxODQ5NiBaIG0gMTgyLjg4NTU4MSwtMjIuODk2NiAxMzcuMTY0MTgsNTEuNDM2NTcgdiAwLjc4NTg0IEwgMjU3LjEyMDQ3LDIzNi4xOTIxNyAxMTkuOTU2MjgsMTgwLjQ2OTIyIHYgLTAuNzg1ODQgeiBtIDIyLjg2MDY5LDI1NC4zMjUyNiBWIDI3Ni4xOTg0IGwgMTE0LjMwMzQ5LC00Ni40MzU4IHYgMTA2LjUwNTE5IHoiCiAgICAgaWQ9InBhdGg0IgogICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjY2NjY2NjYyIKICAgICBzdHlsZT0iZmlsbDojZDlkOWQ5O2ZpbGwtb3BhY2l0eToxIiAvPgogIDxwYXRoCiAgICAgc3R5bGU9ImNvbG9yOiMwMDAwMDA7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHJldGNoOm5vcm1hbDtmb250LXNpemU6bWVkaXVtO2xpbmUtaGVpZ2h0Om5vcm1hbDtmb250LWZhbWlseTpzYW5zLXNlcmlmO2ZvbnQtdmFyaWFudC1saWdhdHVyZXM6bm9ybWFsO2ZvbnQtdmFyaWFudC1wb3NpdGlvbjpub3JtYWw7Zm9udC12YXJpYW50LWNhcHM6bm9ybWFsO2ZvbnQtdmFyaWFudC1udW1lcmljOm5vcm1hbDtmb250LXZhcmlhbnQtYWx0ZXJuYXRlczpub3JtYWw7Zm9udC1mZWF0dXJlLXNldHRpbmdzOm5vcm1hbDt0ZXh0LWluZGVudDowO3RleHQtYWxpZ246c3RhcnQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7dGV4dC1kZWNvcmF0aW9uLWxpbmU6bm9uZTt0ZXh0LWRlY29yYXRpb24tc3R5bGU6c29saWQ7dGV4dC1kZWNvcmF0aW9uLWNvbG9yOiMwMDAwMDA7bGV0dGVyLXNwYWNpbmc6bm9ybWFsO3dvcmQtc3BhY2luZzpub3JtYWw7dGV4dC10cmFuc2Zvcm06bm9uZTt3cml0aW5nLW1vZGU6bHItdGI7ZGlyZWN0aW9uOmx0cjt0ZXh0LW9yaWVudGF0aW9uOm1peGVkO2RvbWluYW50LWJhc2VsaW5lOmF1dG87YmFzZWxpbmUtc2hpZnQ6YmFzZWxpbmU7dGV4dC1hbmNob3I6c3RhcnQ7d2hpdGUtc3BhY2U6bm9ybWFsO3NoYXBlLXBhZGRpbmc6MDtjbGlwLXJ1bGU6bm9uemVybztkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO3Zpc2liaWxpdHk6dmlzaWJsZTtvcGFjaXR5OjE7aXNvbGF0aW9uOmF1dG87bWl4LWJsZW5kLW1vZGU6bm9ybWFsO2NvbG9yLWludGVycG9sYXRpb246c1JHQjtjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM6bGluZWFyUkdCO3NvbGlkLWNvbG9yOiMwMDAwMDA7c29saWQtb3BhY2l0eToxO3ZlY3Rvci1lZmZlY3Q6bm9uZTtmaWxsOiNkOWQ5ZDk7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjIwO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MTtjb2xvci1yZW5kZXJpbmc6YXV0bztpbWFnZS1yZW5kZXJpbmc6YXV0bztzaGFwZS1yZW5kZXJpbmc6YXV0bzt0ZXh0LXJlbmRlcmluZzphdXRvO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgZD0iTSAyMy42MjY5NTMsMjEuNDU3MDMxIFYgMTMwLjcxMDk0IGggMjAgViA0MS40NTcwMzEgaCA5MS45NjY3OTcgdiAtMjAgeiBtIDM1Mi43NzkyOTcsMCB2IDIwIGggOTEuOTY2OCB2IDg5LjI1MzkwOSBoIDIwIFYgMjEuNDU3MDMxIFogTSAyMy42MjY5NTMsMzcxLjUyNTM5IFYgNDg2LjIwMzEyIEggMTM1LjU5Mzc1IHYgLTIwIEggNDMuNjI2OTUzIHYgLTk0LjY3NzczIHogbSA0NDQuNzQ2MDk3LDAgdiA5NC42Nzc3MyBoIC05MS45NjY4IHYgMjAgaCAxMTEuOTY2OCBWIDM3MS41MjUzOSBaIgogICAgIGlkPSJyZWN0ODE5IgogICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+Cjwvc3Zn'"},vr_mode:{light:"'data:image/svg+xml;base64,LjAiIGVuY29kaW5nPSJVVEYtOCIgc3RhbmRhbG9uZT0ibm8iPz4KPHN2ZwogICBmaWxsPSIjMDAwMDAwIgogICBoZWlnaHQ9IjI0IgogICB2aWV3Qm94PSIwIDAgMjQgMjQiCiAgIHdpZHRoPSIyNCIKICAgdmVyc2lvbj0iMS4xIgogICBpZD0ic3ZnOTc2NCIKICAgc29kaXBvZGk6ZG9jbmFtZT0idmlld3BvcnRfdnJfbW9kZS5zdmciCiAgIGlua3NjYXBlOnZlcnNpb249IjEuMi4xICg5YzZkNDFlLCAyMDIyLTA3LTE0KSIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyI+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhOTc3MCI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGRlZnMKICAgICBpZD0iZGVmczk3NjgiIC8+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxIgogICAgIG9iamVjdHRvbGVyYW5jZT0iMTAiCiAgICAgZ3JpZHRvbGVyYW5jZT0iMTAiCiAgICAgZ3VpZGV0b2xlcmFuY2U9IjEwIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxOTIwIgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9Ijk2NiIKICAgICBpZD0ibmFtZWR2aWV3OTc2NiIKICAgICBzaG93Z3JpZD0iZmFsc2UiCiAgICAgaW5rc2NhcGU6em9vbT0iOS44MzMzMzMzIgogICAgIGlua3NjYXBlOmN4PSI0MC4yNzExODciCiAgICAgaW5rc2NhcGU6Y3k9IjEzLjUyNTQyNCIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMTcyOCIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMjUiCiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD0iMSIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJzdmc5NzY0IgogICAgIGlua3NjYXBlOnBhZ2VjaGVja2VyYm9hcmQ9IjAiCiAgICAgaW5rc2NhcGU6c2hvd3BhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6ZGVza2NvbG9yPSIjZDFkMWQxIiAvPgogIDxwYXRoCiAgICAgZD0iTTAgMGgyNHYyNEgweiIKICAgICBmaWxsPSJub25lIgogICAgIGlkPSJwYXRoOTc2MCIgLz4KICA8ZwogICAgIGFyaWEtbGFiZWw9IlZSIgogICAgIGlkPSJ0ZXh0MTA2NiIKICAgICBzdHlsZT0iZm9udC1zaXplOjE2LjMyMzZweDtsaW5lLWhlaWdodDoxLjI1O2ZpbGw6I2Q5ZDlkOTtzdHJva2Utd2lkdGg6MC43NjUxNzEiPgogICAgPHBhdGgKICAgICAgIGQ9Ik0gMTEuNzYwODg1LDYuMDY1OTU3MiA3LjY3OTk4NDQsMTcuOTM0MDQ0IEggNS45NzQyOTU2IEwgMS44OTMzOTU1LDYuMDY1OTU3MiBIIDMuNTgzMTQzMiBMIDYuODY2OTkyNiwxNS45MTc1MDUgMTAuMTUwODQyLDYuMDY1OTU3MiBaIgogICAgICAgc3R5bGU9ImZvbnQtZmFtaWx5OlRhaG9tYTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOlRhaG9tYSIKICAgICAgIGlkPSJwYXRoMjUwNiIgLz4KICAgIDxwYXRoCiAgICAgICBkPSJtIDIyLjA5MDY2MywxNy45MzQwNDQgaCAtMi4wNDg0MjEgbCAtMy43NjIwOCwtNC43MTg1NDEgaCAtMS44MDEzMzQgdiA0LjcxODU0MSBIIDEyLjkwMDY2NyBWIDYuMDY1OTU3MiBoIDMuMDYwNjc1IHEgMS4wMjAyMjUsMCAxLjcwNTY4OSwwLjExMTU4NzEgMC42OTM0MzQsMC4xMTE1ODcxIDEuMzE1MTM0LDAuNTE4MDgzIDAuNjIxNjk5LDAuMzk4NTI1NCAwLjk4MDM3MiwxLjAyODE5NTYgMC4zNjY2NDQsMC42Mjk2NzAxIDAuMzY2NjQ0LDEuNTYyMjE5NiAwLDEuMzA3MTYzNSAtMC42NjE1NTMsMi4xODM5MTk1IC0wLjY2MTU1MiwwLjg3Njc1NiAtMS44MDEzMzQsMS4yOTkxOTMgeiBNIDE4LjY3OTI4NSw5LjQwNTYwMDEgcSAwLC0wLjUxODA4MyAtMC4xODMzMjEsLTAuOTE2NjA4NCBRIDE4LjMxMjY0Miw4LjA4MjQ5NTggMTcuOTMwMDU4LDcuODI3NDM5NSAxNy41OTUyOTYsNy42MDQyNjUzIDE3LjE0ODk0OCw3LjUxNjU4OTcgMTYuNzAyNTk5LDcuNDIwOTQzNiAxNi4wNDEwNDcsNy40MjA5NDM2IGggLTEuNTYyMjE5IHYgNC40Nzk0MjU0IGggMS4zODY4NjggcSAwLjY3NzQ5MywwIDEuMjE5NDg4LC0wLjExOTU1NyAwLjU0MTk5NCwtMC4xMTk1NTggMC45MjQ1NzksLTAuNDk0MTcyIDAuMzQyNzMyLC0wLjMzNDc2MSAwLjUwMjE0MiwtMC43OTcwNTEgMC4xNjczOCwtMC40NjIyODkgMC4xNjczOCwtMS4wODM5ODg5IHoiCiAgICAgICBzdHlsZT0iZm9udC1mYW1pbHk6VGFob21hOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246VGFob21hIgogICAgICAgaWQ9InBhdGgyNTA4IiAvPgogIDwvZz4KPC9zdmc='"}};var d=t(3379),h=t.n(d),f=t(7795),u=t.n(f),p=t(569),m=t.n(p),g=t(3565),v=t.n(g),y=t(9216),I=t.n(y),T=t(4589),b=t.n(T),L=t(8743),w={};w.styleTagTransform=b(),w.setAttributes=v(),w.insert=m().bind(null,"head"),w.domAPI=u(),w.insertStyleElement=I(),h()(L.Z,w),L.Z&&L.Z.locals&&L.Z.locals;class O{constructor(){this.domElement=document.createElement("div"),this.domElement.style.position="absolute",this.domElement.style.bottom=0,this.domElement.style.right=0,this.domElement.style.zIndex="999"}addButton(e,n){const t=document.createElement("button");t.className="jupyter-ovito-toolbtn",this.domElement.appendChild(t),t.setAttribute("style",`background-image: url(${l[e].light});`),t.addEventListener("click",n)}}var x=t(4439);class M{constructor(e){this.linesThick=new i.ShaderMaterial({name:"linesThick",vertexColors:!0,vertexShader:t(9439),fragmentShader:t(7836),uniforms:{line_thickness:{value:new i.Vector2}}}),this.spheresAsRaycastingQuads=new i.ShaderMaterial({name:"spheresAsRaycastingQuads",vertexColors:!0,vertexShader:t(9689),fragmentShader:t(e?3268:8338),alphaToCoverage:e,extensions:{fragDepth:!0,derivatives:e}}),this.spheresImposterQuads=new i.ShaderMaterial({name:"spheresImposterQuads",vertexColors:!0,vertexShader:t(3724),fragmentShader:t(e?5636:2923),alphaToCoverage:e,extensions:{derivatives:e}}),this.circles=new i.ShaderMaterial({name:"circles",vertexColors:!0,vertexShader:t(8135),fragmentShader:t(e?8686:5418),alphaToCoverage:e,extensions:{derivatives:e}}),this.cubes=new i.ShaderMaterial({name:"cubes",vertexColors:!0,vertexShader:t(637),fragmentShader:t(5235)}),this.squares=new i.ShaderMaterial({name:"squares",vertexColors:!0,vertexShader:t(5988),fragmentShader:t(798)}),this.ellipsoids=new i.ShaderMaterial({name:"ellipsoids",vertexColors:!0,vertexShader:t(2322),fragmentShader:t(4617),extensions:{fragDepth:!0}}),this.superquadrics=new i.ShaderMaterial({name:"superquadrics",vertexColors:!0,vertexShader:t(538),fragmentShader:t(7098),extensions:{fragDepth:!0}}),this.cylinders=new i.ShaderMaterial({name:"cylinders",vertexColors:!1,vertexShader:t(3568),fragmentShader:t(2293),defines:{SINGLE_CYLINDER_CAP:0},uniforms:{color_map:{value:void 0},color_range_min:{value:void 0},color_range_max:{value:void 0}},extensions:{fragDepth:!0}}),this.cylindersFlat=new i.ShaderMaterial({name:"cylindersFlat",vertexColors:!1,vertexShader:t(8591),fragmentShader:t(6456),uniforms:{color_map:{value:void 0},color_range_min:{value:void 0},color_range_max:{value:void 0}}}),this.arrowHeads=new i.ShaderMaterial({name:"arrowHeads",vertexColors:!1,vertexShader:t(8799),fragmentShader:t(6115),extensions:{fragDepth:!0}}),this.arrowTails=new i.ShaderMaterial({name:"arrowTails",vertexColors:!1,vertexShader:t(4644),fragmentShader:t(2293),defines:{SINGLE_CYLINDER_CAP:1},extensions:{fragDepth:!0}}),this.arrowsFlat=new i.ShaderMaterial({name:"arrowsFlat",vertexColors:!1,vertexShader:t(7298),fragmentShader:t(8132)}),this.mesh=new i.ShaderMaterial({name:"mesh",vertexColors:!0,side:i.DoubleSide,vertexShader:t(4484),fragmentShader:t(7575),uniforms:{color_map:{value:void 0},opacity:{value:void 0},color_range_min:{value:void 0},color_range_max:{value:void 0},selection_color:{value:void 0}}}),this.meshWireframe=new i.ShaderMaterial({name:"meshWireframe",vertexShader:t(1717),fragmentShader:t(2735),uniforms:{wireframe_color:{value:new i.Vector4(.1,.1,.1,1)}}})}dispose(){for(const e in this){const n=this[e];if(n.isMaterial){if(n.dispose(),n.variations)for(const e of n.variations)e.dispose();delete this[e]}}}lookup(e,n){if(x.isMatch(e,n))return e;e.variations||(e.variations=[]);for(const t of e.variations)if(x.isMatch(t,n))return t;const t=e.clone();return x.merge(t,n),e.variations.push(t),t}}var G=t(553);function C(e){let n,t;switch(e.targetRayMode){case"tracked-pointer":n=new i.BufferGeometry;const e=.01,o=[.6,.6,.4];return n.setAttribute("position",new i.Float32BufferAttribute([e,0,0,e,0,-1,-e,0,-1,e,0,0,-e,0,-1,-e,0,0],3)),n.setAttribute("color",new i.Float32BufferAttribute([o[0],o[1],o[2],0,0,0,0,0,0,o[0],o[1],o[2],0,0,0,o[0],o[1],o[2]],3)),t=new i.MeshBasicMaterial({vertexColors:!0,blending:i.AdditiveBlending,side:i.DoubleSide}),new i.Mesh(n,t);case"gaze":return n=new i.RingGeometry(.02,.04,32).translate(0,0,-1),t=new i.MeshBasicMaterial({opacity:.5,transparent:!0}),new i.Mesh(n,t)}}function P(e,n){n.fromArray(e)}class A extends i.EventDispatcher{constructor(e){super(),this.addEventListener("camera_changed",(function(n){console.assert(!0===n.camera.isCamera),e.setObject(n.camera)}))}isValid(){return void 0!==this.camera}unpack(e){var n,t;e&&(this.isValid()&&e.perspective==!!this.camera.isPerspectiveCamera||(this.camera=e.perspective?new i.PerspectiveCamera(50,1,1,100):new i.OrthographicCamera(-1,1,1,-1,1,100),this.camera.matrixAutoUpdate=!1,this.dispatchEvent({type:"camera_changed",camera:this.camera})),this.camera.isPerspectiveCamera?this.camera.fov=180*e.fov/Math.PI:this.camera.zoom=1/e.fov,P(e.up,this.camera.up),0==this.camera.up.lengthSq()&&this.camera.up.set(0,0,1),n=e.matrix,(t=this.camera.matrix).elements[0]=n[0][0],t.elements[4]=n[0][1],t.elements[8]=n[0][2],t.elements[12]=n[0][3],t.elements[1]=n[1][0],t.elements[5]=n[1][1],t.elements[9]=n[1][2],t.elements[13]=n[1][3],t.elements[2]=n[2][0],t.elements[6]=n[2][1],t.elements[10]=n[2][2],t.elements[14]=n[2][3],t.elements[3]=0,t.elements[7]=0,t.elements[11]=0,t.elements[15]=1,this.camera.updateMatrixWorld(!0))}pack(){return void 0!==this.camera?{perspective:!!this.camera.isPerspectiveCamera,fov:this.camera.isPerspectiveCamera?this.camera.fov*Math.PI/180:1/this.camera.zoom,matrix:(n=this.camera.matrix,[[n.elements[0],n.elements[4],n.elements[8],n.elements[12]],[n.elements[1],n.elements[5],n.elements[9],n.elements[13]],[n.elements[2],n.elements[6],n.elements[10],n.elements[14]]]),up:(e=this.camera.up,[e.x,e.y,e.z])}:null;var e,n}static computeProjectionParameters(e,n,t){if(void 0===t)return;t.updateWorldMatrix(!0,!1);const o=e.clone().applyMatrix4(t.matrixWorldInverse).expandByScalar(1.01);t.isPerspectiveCamera?(o.min.z<0?(t.far=-o.min.z,t.near=Math.max(-o.max.z,1e-4*t.far)):(t.far=Math.max(o.getSize(new i.Vector3).length(),1),t.near=1e-4*t.far),t.far=Math.max(t.far,1.01*t.near),t.aspect=n):(o.isEmpty()?(t.near=1,t.far=100):(t.near=-o.max.z,t.far=-o.min.z,t.far<=t.near&&(t.far=t.near+1)),t.left=-n,t.right=n),t.updateProjectionMatrix()}zoomToBox(e){if(!e.isEmpty()&&this.camera){if(this.camera.isPerspectiveCamera){const n=.5*e.getSize(new i.Vector3).length()/Math.tan(.5*this.camera.fov*Math.PI/180),t=(new i.Vector3).setFromMatrixColumn(this.camera.matrix,2).normalize(),o=e.getCenter(new i.Vector3).addScaledVector(t,n);this.camera.matrix.setPosition(o)}else{this.camera.updateMatrixWorld(!1);const n=new i.Vector3,t=new i.Box2;for(let i=0;i<8;i++)n.x=1&i?e.max.x:e.min.x,n.y=2&i?e.max.y:e.min.y,n.z=4&i?e.max.z:e.min.z,t.expandByPoint(n.applyMatrix4(this.camera.matrixWorldInverse));const o=Math.max(t.max.X-t.min.x,1e-12),r=Math.max(t.max.y-t.min.y,1e-12),a=this.camera.bottom/this.camera.right;this.camera.zoom=1/.55/(a>r/o?o*a:r),this.camera.matrix.setPosition(e.getCenter(n)),this.camera.updateMatrixWorld(!0)}this.camera.updateMatrixWorld(!0)}}}const N={Float32:Float32Array,Int32:Int32Array,Int64:BigInt64Array,Uint8:Uint8Array},S={lines:function(e,n){const t=new i.BufferGeometry,o=void 0!==n.picking_base_id;if(1==n.line_width||n.line_width<=0&&e.renderer.getPixelRatio()<=1){console.assert(!o),t.setAttribute("position",e.lookupBufferAttribute(n.positions)),n.colors&&t.setAttribute("color",e.lookupBufferAttribute(n.colors));const r=(new i.Color).fromArray(n.uniform_color),a=new i.LineBasicMaterial({color:r});return new i.LineSegments(t,a)}{const r=e.lookupBufferAttribute(n.positions),a=e.lookupBufferAttribute(n.colors),s=r.count/2,c=new Uint32Array(2*s*3),l=new Float32Array(4*s*3),d=new Float32Array(4*s*3),h=o?null:new Float32Array(4*s*4);let f=0,u=0,p=0;for(let e=0,t=0;e<s;e++,t+=4){for(let t=0;t<4;t++,f+=3)l[f+0]=r.getX(2*e),l[f+1]=r.getY(2*e),l[f+2]=r.getZ(2*e),d[f+0]=r.getX(2*e+1),d[f+1]=r.getY(2*e+1),d[f+2]=r.getZ(2*e+1),o||(h[p++]=a?a.getX(2*e+(t<2?0:1)):n.uniform_color[0],h[p++]=a?a.getY(2*e+(t<2?0:1)):n.uniform_color[1],h[p++]=a?a.getZ(2*e+(t<2?0:1)):n.uniform_color[2],h[p++]=a?a.getW(2*e+(t<2?0:1)):n.uniform_color[3]);for(let e=2;e<4;e++)c[u++]=t,c[u++]=e-1+t,c[u++]=e+t}console.assert(f==l.length),console.assert(u==c.length),console.assert(o||p==h.length),t.setAttribute("position",new i.BufferAttribute(l,3)),t.setAttribute("position2",new i.BufferAttribute(d,3)),h&&t.setAttribute("color",new i.BufferAttribute(h,4)),t.setIndex(new i.BufferAttribute(c,1,!1));const m=new i.Mesh(t,e.materials.linesThick);o&&(m.layers.set(1),m.material=e.materials.lookup(m.material,{vertexColors:!1,alphaToCoverage:!1,defines:{OBJECT_PICKING_MODE:1}}));const g=n.line_width<=0?e.renderer.getPixelRatio():n.line_width,v=o?new i.Uniform(n.picking_base_id):void 0;return m.onBeforeRender=function(e,n,t,o,r,a){const s=e.getCurrentViewport(new i.Vector4);r.uniforms.line_thickness.value.x=g/s.w,r.uniforms.line_thickness.value.y=g/s.z,void 0!==v&&(r.uniforms.picking_base_id=v),r.uniformsNeedUpdate=!0},m.frustumCulled=!1,m}},particles:function(e,n){const t=e.lookupBufferAttribute(n.positions),o=e.lookupBufferAttribute(n.indices),r=e.lookupBufferAttribute(n.colors),a=e.lookupBufferAttribute(n.transparencies),s=e.lookupBufferAttribute(n.radii),c=e.lookupBufferAttribute(n.aspherical_shapes),l=e.lookupBufferAttribute(n.orientations),d=e.lookupBufferAttribute(n.roundness),h=o?o.count:t.count;let f,u,p,m,g,v=null;const y=new i.BufferGeometry,_=void 0!==n.picking_base_id;if("spherical"==n.shape){"normal"==n.shading_mode?v="low"!==n.rendering_quality?e.materials.spheresAsRaycastingQuads:e.materials.spheresImposterQuads:"flat"==n.shading_mode&&(v=e.materials.circles),f=new Uint32Array(6*h),u=new Float32Array(4*h*3),p=new Float32Array(4*h),_||(m=new Float32Array(4*h*4));let i=0,c=0,l=0,d=0;for(let e=0,g=0;e<h;e++,g+=4){let h=o?o.array[e]:e,v=a?1-a.array[h]:1,y=s?s.array[h]:n.uniform_radius;for(let e=0;e<4;e++)u[i++]=t.getX(h),u[i++]=t.getY(h),u[i++]=t.getZ(h),_||(m[l++]=r?r.getX(h):n.uniform_color[0],m[l++]=r?r.getY(h):n.uniform_color[1],m[l++]=r?r.getZ(h):n.uniform_color[2],m[l++]=v),p[d++]=y;for(let e=2;e<4;e++)f[c++]=g,f[c++]=e-1+g,f[c++]=e+g}console.assert(i==u.length),console.assert(c==f.length),console.assert(_||l==m.length),console.assert(d==p.length)}else if("square_cubic"==n.shape||"box"==n.shape||"ellipsoid"==n.shape||"superquadric"==n.shape)if("normal"==n.shading_mode){let p,I;"ellipsoid"==n.shape?(v=e.materials.ellipsoids,p=new Float32Array(24*h*16)):"superquadric"==n.shape?(v=e.materials.superquadrics,p=new Float32Array(24*h*16),I=new Float32Array(24*h*2)):v=e.materials.cubes,f=new Uint32Array(36*h),u=new Float32Array(24*h*3),g=new Float32Array(24*h*3),_||(m=new Float32Array(24*h*4));let T=0,b=0,L=0,w=0,O=0,x=0;for(let e=0;e<h;e++){let i=o?o.array[e]:e,h=a?1-a.array[i]:1,v=s?s.array[i]:n.uniform_radius,y=c?[c.getX(i),c.getY(i),c.getZ(i)]:[v,v,v];0==y[0]&&0==y[1]&&0==y[1]&&(y=[v,v,v]);let M=t.getX(i),G=t.getY(i),C=t.getZ(i),P=0,A=0,N=0,S=1;if(l){P=l.getX(i),A=l.getY(i),N=l.getZ(i),S=l.getW(i);let e=Math.sqrt(P*P+A*A+N*N+S*S);e>=1e-9?(P/=e,A/=e,N/=e,S/=e):S=1}const E=[[y[0],0,0],[0,y[1],0],[0,0,y[2]]];for(let e=0;e<3;e++){const n=E[e][0],t=E[e][1],i=E[e][2],o=S*n+A*i-N*t,r=S*t+N*n-P*i,a=S*i+P*t-A*n,s=-P*n-A*t-N*i;E[e]=[o*S+s*-P+r*-N-a*-A,r*S+s*-A+a*-P-o*-N,a*S+s*-N+o*-A-r*-P]}for(let e=0;e<3;e++)for(let t=-1;t<2;t+=2){for(let o=0;o<4;o++)if(g[b++]=t*E[e][0]/y[e],g[b++]=t*E[e][1]/y[e],g[b++]=t*E[e][2]/y[e],_||(m[L++]=r?r.getX(i):n.uniform_color[0],m[L++]=r?r.getY(i):n.uniform_color[1],m[L++]=r?r.getZ(i):n.uniform_color[2],m[L++]=h),p){for(let e=0;e<3;e++)p[O++]=E[e][0],p[O++]=E[e][1],p[O++]=E[e][2],p[O++]=1;p[O++]=M,p[O++]=G,p[O++]=C,p[O++]=1,I&&(I[x++]=d?d.getX(i):1,I[x++]=d?d.getY(i):1)}let o=T/3;f[w++]=o,f[w++]=o+1,f[w++]=o+2,f[w++]=o,f[w++]=o+2,f[w++]=o+3,u[T++]=M+t*(E[e][0]+E.at(e-1)[0])-E.at(e-2)[0],u[T++]=G+t*(E[e][1]+E.at(e-1)[1])-E.at(e-2)[1],u[T++]=C+t*(E[e][2]+E.at(e-1)[2])-E.at(e-2)[2],u[T++]=M+t*(E[e][0]-E.at(e-1)[0])-E.at(e-2)[0],u[T++]=G+t*(E[e][1]-E.at(e-1)[1])-E.at(e-2)[1],u[T++]=C+t*(E[e][2]-E.at(e-1)[2])-E.at(e-2)[2],u[T++]=M+t*(E[e][0]-E.at(e-1)[0])+E.at(e-2)[0],u[T++]=G+t*(E[e][1]-E.at(e-1)[1])+E.at(e-2)[1],u[T++]=C+t*(E[e][2]-E.at(e-1)[2])+E.at(e-2)[2],u[T++]=M+t*(E[e][0]+E.at(e-1)[0])+E.at(e-2)[0],u[T++]=G+t*(E[e][1]+E.at(e-1)[1])+E.at(e-2)[1],u[T++]=C+t*(E[e][2]+E.at(e-1)[2])+E.at(e-2)[2]}}console.assert(T==u.length),console.assert(w==f.length),console.assert(b==g.length),console.assert(_||L==m.length),p&&(console.assert(O==p.length),y.setAttribute("shape_orientation",new i.BufferAttribute(p,16))),I&&(console.assert(x==I.length),y.setAttribute("roundness",new i.BufferAttribute(I,2)))}else if("flat"==n.shading_mode&&"square_cubic"==n.shape){v=e.materials.squares,f=new Uint32Array(6*h),u=new Float32Array(4*h*3),p=new Float32Array(4*h),_||(m=new Float32Array(4*h*4));let i=0,c=0,l=0,d=0;for(let e=0,g=0;e<h;e++,g+=4){let h=o?o.array[e]:e,v=a?1-a.array[h]:1,y=s?s.array[h]:n.uniform_radius;for(let e=0;e<4;e++)u[i++]=t.getX(h),u[i++]=t.getY(h),u[i++]=t.getZ(h),_||(m[l++]=r?r.getX(h):n.uniform_color[0],m[l++]=r?r.getY(h):n.uniform_color[1],m[l++]=r?r.getZ(h):n.uniform_color[2],m[l++]=v),p[d++]=y;for(let e=2;e<4;e++)f[c++]=g,f[c++]=e-1+g,f[c++]=e+g}console.assert(i==u.length),console.assert(c==f.length),console.assert(_||l==m.length),console.assert(d==p.length)}if(!v)return null;y.setAttribute("position",new i.BufferAttribute(u,3)),m&&y.setAttribute("color",new i.BufferAttribute(m,4)),p&&y.setAttribute("radius",new i.BufferAttribute(p,1)),g&&y.setAttribute("normal",new i.BufferAttribute(g,3)),f&&y.setIndex(new i.BufferAttribute(f,1,!1)),_&&(v=e.materials.lookup(v,{vertexColors:!1,alphaToCoverage:!1,defines:{OBJECT_PICKING_MODE:1}}));const I=new i.Mesh(y,v);if(I.frustumCulled=!1,_){I.layers.set(1);const e=new i.Uniform(n.picking_base_id);I.onBeforeRender=function(n,t,i,o,r,a){r.uniforms.picking_base_id=e,r.uniformsNeedUpdate=!0},console.assert(!v.alphaToCoverage)}else v.alphaToCoverage&&(I.onBeforeRender=function(e){e.getContext().colorMask(!0,!0,!0,!1)},I.onAfterRender=function(e){e.getContext().colorMask(!0,!0,!0,!0)});return I},cylinders:function(e,n){const t=e.lookupBufferAttribute(n.base_positions),o=e.lookupBufferAttribute(n.head_positions),r=e.lookupBufferAttribute(n.colors),a=e.lookupBufferAttribute(n.transparencies),s=e.lookupBufferAttribute(n.widths),c=void 0!==n.picking_base_id,l={defines:{SINGLE_CYLINDER_CAP:0}};let d,h,f,u,p,m,g,v=null;const y=new i.BufferGeometry;if("normal"==n.shading_mode){"cylinder"==n.shape?(v=e.materials.cylinders,n.single_cap&&(l.defines.SINGLE_CYLINDER_CAP=1)):"arrow"==n.shape&&(v=e.materials.arrowTails);const y=t.count,_=24,I=12,T=new i.Vector3,b=new i.Vector3,L=new i.Vector3,w=new i.Vector3,O=new i.Vector3,x=[L,w,O];d=new Uint32Array(3*I*y),h=new Float32Array(3*_*y),m=new Float32Array(3*_*y),g=new Float32Array(3*_*y),c||(f=new Float32Array(4*_*y),u=new Float32Array(4*_*y)),p=new Float32Array(_*y);let M=0,G=0,C=0,P=0,A=0;for(let e=0;e<y;e++){const i=a?1-a.array[e]:1,l=.5*(s?s.array[e]:n.uniform_width);T.fromBufferAttribute(t,e),b.fromBufferAttribute(o,e),O.subVectors(b,T),0!==O.x||0!==O.y||0!==O.z?(0!==O.x||0!==O.y?L.set(O.y,-O.x,0).setLength(l):L.set(-O.z,0,O.x).setLength(l),w.crossVectors(O,L).setLength(l),O.multiplyScalar(.5)):(L.setScalar(0),w.setScalar(0));const v=T.x+O.x,y=T.y+O.y,_=T.z+O.z;let I,N,S,E,D,F;c||(r?r.count==t.count?(I=E=r.getX(e),N=D=3==r.itemSize?r.getY(e):0,S=F=3==r.itemSize?r.getZ(e):0):(I=r.getX(2*e),N=3==r.itemSize?r.getY(2*e):0,S=3==r.itemSize?r.getZ(2*e):0,E=r.getX(2*e+1),D=3==r.itemSize?r.getY(2*e+1):0,F=3==r.itemSize?r.getZ(2*e+1):0):(I=E=n.uniform_color[0],N=D=n.uniform_color[1],S=F=n.uniform_color[2]));for(let e=0;e<3;e++)for(let n=-1;n<2;n+=2){for(let e=0;e<4;e++,G+=4,A+=3)c||(f[G+0]=I,f[G+1]=N,f[G+2]=S,f[G+3]=i,u[G+0]=E,u[G+1]=D,u[G+2]=F,u[G+3]=i),m[A+0]=T.x,m[A+1]=T.y,m[A+2]=T.z,g[A+0]=b.x,g[A+1]=b.y,g[A+2]=b.z,p[P++]=l;let t=M/3;d[C++]=t,d[C++]=t+1,d[C++]=t+2,d[C++]=t,d[C++]=t+2,d[C++]=t+3,h[M++]=v+n*(x[e].x+x.at(e-1).x)-x.at(e-2).x,h[M++]=y+n*(x[e].y+x.at(e-1).y)-x.at(e-2).y,h[M++]=_+n*(x[e].z+x.at(e-1).z)-x.at(e-2).z,h[M++]=v+n*(x[e].x-x.at(e-1).x)-x.at(e-2).x,h[M++]=y+n*(x[e].y-x.at(e-1).y)-x.at(e-2).y,h[M++]=_+n*(x[e].z-x.at(e-1).z)-x.at(e-2).z,h[M++]=v+n*(x[e].x-x.at(e-1).x)+x.at(e-2).x,h[M++]=y+n*(x[e].y-x.at(e-1).y)+x.at(e-2).y,h[M++]=_+n*(x[e].z-x.at(e-1).z)+x.at(e-2).z,h[M++]=v+n*(x[e].x+x.at(e-1).x)+x.at(e-2).x,h[M++]=y+n*(x[e].y+x.at(e-1).y)+x.at(e-2).y,h[M++]=_+n*(x[e].z+x.at(e-1).z)+x.at(e-2).z}}console.assert(M==h.length),console.assert(C==d.length),console.assert(c||G==f.length),console.assert(P==p.length),console.assert(A==m.length)}else if("flat"==n.shading_mode){let l,y;"cylinder"==n.shape?(v=e.materials.cylindersFlat,l=4,y=2):"arrow"==n.shape&&(v=e.materials.arrowsFlat,l=7,y=5);const _=t.count,I=new i.Vector3,T=new i.Vector3;d=new Uint32Array(3*y*_),h=new Float32Array(3*l*_),m=new Float32Array(3*l*_),g=new Float32Array(3*l*_),c||(f=new Float32Array(4*l*_),u=new Float32Array(4*l*_)),p=new Float32Array(l*_);let b=0,L=0,w=0,O=0;for(let e=0;e<_;e++){const i=a?1-a.array[e]:1,h=.5*(s?s.array[e]:n.uniform_width);let v,_,x;c||(v=r?r.getX(e):n.uniform_color[0],_=r?r.getY(e):n.uniform_color[1],x=r?r.getZ(e):n.uniform_color[2]),I.fromBufferAttribute(t,e),T.fromBufferAttribute(o,e);for(let e=0;e<l;e++,b+=4,O+=3)c||(f[b+0]=v,f[b+1]=_,f[b+2]=x,f[b+3]=i,u[b+0]=v,u[b+1]=_,u[b+2]=x,u[b+3]=i),m[O+0]=I.x,m[O+1]=I.y,m[O+2]=I.z,g[O+0]=T.x,g[O+1]=T.y,g[O+2]=T.z,p[w++]=h;let M=e*l;for(let e=0;e<y;e++)d[L++]=M,d[L++]=M+1+e,d[L++]=M+2+e}console.assert(L==d.length),console.assert(c||b==f.length),console.assert(w==p.length),console.assert(O==m.length)}if(!v)return null;y.setAttribute("position",new i.BufferAttribute(h,3)),y.setAttribute("base",new i.BufferAttribute(m,3)),y.setAttribute("head",new i.BufferAttribute(g,3)),f&&y.setAttribute("color1",new i.BufferAttribute(f,4)),u&&y.setAttribute("color2",new i.BufferAttribute(u,4)),y.setAttribute("radius",new i.BufferAttribute(p,1)),y.setIndex(new i.BufferAttribute(d,1,!1));const _=new i.Mesh(y,v);if(_.frustumCulled=!1,"arrow"===n.shape&&"normal"===n.shading_mode){const t=new i.Mesh(y,e.materials.arrowHeads);if(t.frustumCulled=!1,_.add(t),c){t.layers.set(1),t.material=e.materials.lookup(t.material,{vertexColors:!1,alphaToCoverage:!1,defines:{OBJECT_PICKING_MODE:1}});const o=new i.Uniform(n.picking_base_id);t.onBeforeRender=function(e,n,t,i,r,a){r.uniforms.picking_base_id=o,r.uniformsNeedUpdate=!0}}}if(n.pseudocolor_gradient){l.defines.USE_PSEUDOCOLORS=1;const t=e.lookupTexture(n.pseudocolor_gradient),i=n.pseudocolor_range;_.onBeforeRender=function(e,n,o,r,a,s){a.uniforms.color_map.value=t,a.uniforms.color_range_min.value=i[0],a.uniforms.color_range_max.value=i[1],a.uniformsNeedUpdate=!0},console.assert(!c)}else if(c){_.layers.set(1),l.vertexColors=!1,l.alphaToCoverage=!1,l.defines.OBJECT_PICKING_MODE=1;const e=new i.Uniform(n.picking_base_id);_.onBeforeRender=function(n,t,i,o,r,a){r.uniforms.picking_base_id=e,r.uniformsNeedUpdate=!0}}return _.material=e.materials.lookup(_.material,l),console.assert(_.material===e.materials.lookup(_.material,l)),_},mesh:function(e,n){const t=new i.BufferGeometry,o=void 0!==n.picking_base_id,r=new i.InterleavedBuffer(new Float32Array(n.render_vertices.data.buffer),n.render_vertices.components);console.assert(r.count==n.render_vertices.size),t.setAttribute("position",new i.InterleavedBufferAttribute(r,3,0,!1)),o||(t.setAttribute("normal",new i.InterleavedBufferAttribute(r,3,3,!1)),t.setAttribute("color",new i.InterleavedBufferAttribute(r,4,6,!1)));const a=e.lookupBufferAttribute(n.instance_matrices),s=e.lookupBufferAttribute(n.instance_colors);console.assert(!o||!s);const c=a?new i.InstancedMesh(t,e.materials.mesh,a.count):new i.Mesh(t,e.materials.mesh),l={side:n.backface_culling?i.FrontSide:i.DoubleSide};if(!1!==n.is_fully_opaque||o||(l.transparent=!0),n.pseudocolor_gradient){l.defines={USE_PSEUDOCOLORS:1};const t=e.lookupTexture(n.pseudocolor_gradient),i=n.uniform_color[3],o=n.pseudocolor_range,r=n.selection_color;c.onBeforeRender=function(e,n,a,s,c,l){c.uniforms.color_map.value=t,c.uniforms.opacity.value=i,c.uniforms.color_range_min.value=o[0],c.uniforms.color_range_max.value=o[1],c.uniforms.selection_color.value=r,c.uniformsNeedUpdate=!0}}if(a){if(s){c.instanceColor=new i.InstancedBufferAttribute(new Float32Array(3*s.count),3);for(let e=0;e<s.count;e++)c.instanceColor.array[3*e+0]=s.array[4*e+0],c.instanceColor.array[3*e+1]=s.array[4*e+1],c.instanceColor.array[3*e+2]=s.array[4*e+2]}else if(o){c.instanceColor=new i.InstancedBufferAttribute(new Uint8Array(3*a.count),3,!0);for(let e=0;e<a.count;e++){const t=e+n.picking_base_id;c.instanceColor.array[3*e+0]=t%256,c.instanceColor.array[3*e+1]=t/256%256,c.instanceColor.array[3*e+2]=t/65536%256}}for(let e=0;e<a.count;e++){for(let n=0;n<4;n++)for(let t=0;t<3;t++)c.instanceMatrix.array[16*e+4*n+t]=a.array[12*e+3*n+t];c.instanceMatrix.array[16*e+0+3]=0,c.instanceMatrix.array[16*e+4+3]=0,c.instanceMatrix.array[16*e+8+3]=0,c.instanceMatrix.array[16*e+12+3]=1}}if(n.wireframe_lines){console.assert(!o);const t=a?new i.InstancedBufferGeometry:new i.BufferGeometry;a&&(t.instanceCount=a.count,t.setAttribute("instanceMatrix",c.instanceMatrix)),t.setAttribute("position",e.lookupBufferAttribute(n.wireframe_lines)),l.polygonOffset=!0,l.polygonOffsetFactor=1,l.polygonOffsetUnits=1;const r={};a&&(r.defines={USE_INSTANCING:1});const s=n.uniform_color[3];s<1&&(r.transparent=!0);const d=new i.LineSegments(t,e.materials.lookup(e.materials.meshWireframe,r));d.onBeforeRender=function(e,n,t,i,o,r){o.uniforms.wireframe_color.value.w=s,o.uniformsNeedUpdate=!0},c.add(d)}if(o){c.layers.set(1),l.vertexColors=!1,l.alphaToCoverage=!1,l.defines={OBJECT_PICKING_MODE:1};const e=new i.Uniform(n.picking_base_id);c.onBeforeRender=function(n,t,i,o,r,a){r.uniforms.picking_base_id=e,r.uniformsNeedUpdate=!0}}return c.material=e.materials.lookup(c.material,l),console.assert(c.material===e.materials.lookup(c.material,l)),c}};class E extends i.EventDispatcher{constructor(e,n){super(),this.materials=e,this.renderer=n,this.scene=new i.Scene,this.primitivesContainer=new i.Group,this.primitivesContainer.boundingBox=new i.Box3,this.scene.add(this.primitivesContainer),this.datasetContainer=new i.Group,this.datasetContainer.add(this.primitivesContainer),this.scene.add(this.datasetContainer),this.vrContainer=new i.Group,this.vrContainer.visible=!1,this.scene.add(this.vrContainer),this.vrCamera=new i.PerspectiveCamera,this.vrCamera.matrixAutoUpdate=!1,this.vrContainer.add(new i.HemisphereLight(6316128,4210752));const t=new i.DirectionalLight(16777215);t.position.set(1,1,1).normalize(),this.vrContainer.add(t),this.buffers=new Map,this.textures=new Map}dispose(){this.scene.traverse((function(e){e.isMesh&&e.geometry.dispose()})),delete this.primitivesContainer,delete this.datasetContainer,delete this.vrContainer,delete this.scene}getBoundingBox(){let e=this.primitivesContainer.boundingBox.clone().applyMatrix4(this.primitivesContainer.matrixWorld);return this.vrContainer.visible&&e.expandByObject(this.vrContainer,!1),e}unpackDataArrays(e){this.textures.forEach((function(e){e.dispose()})),this.buffers.clear(),this.textures.clear();for(const n in e){const t=e[n],o=N[t.type];if(void 0!==o)if(Array.isArray(t.size)){const e=new i.DataTexture(new o(t.data.buffer,t.data.byteOffset,t.data.byteLength/o.BYTES_PER_ELEMENT),t.size[0],t.size[1]);e.needsUpdate=!0,this.textures.set(parseInt(n),e)}else console.assert(o.BYTES_PER_ELEMENT*t.size*t.components===t.data.byteLength),this.buffers.set(parseInt(n),new i.BufferAttribute(new o(t.data.buffer,t.data.byteOffset,t.data.byteLength/o.BYTES_PER_ELEMENT),t.components,!1));else console.error("Unsupported data array type:",t.type)}}unpack(e){if(this.primitivesContainer.traverse((function(e){e.isMesh&&e.geometry.dispose()})),this.primitivesContainer.clear(),this.unpackDataArrays(e.arrays||{}),!_.isEmpty(e)){for(const n of e.objects){const e=S[n.primitive_type];if(void 0===e){console.log("Encountered unsupported rendering primitive type in scene model: primitive_type="+n.primitive_type);continue}const t=e(this,n);void 0!==t&&(t.matrixAutoUpdate=!1,t.frustumCulled=!1,this.primitivesContainer.add(t),t.matrix.fromArray(n.model_view_tm.flat()),t.updateMatrixWorld(!0))}this.primitivesContainer.boundingBox.min.fromArray(e.bounding_box[0]),this.primitivesContainer.boundingBox.max.fromArray(e.bounding_box[1]),this.dispatchEvent({type:"bounding_box_changed",bounding_box:this.primitivesContainer.boundingBox})}}lookupBufferAttribute(e){if(!e)return null;if(e.isBufferAttribute)return e;const n=this.buffers.get(e);return void 0===n&&console.error("Non-existent buffer ID:",e),n}lookupTexture(e){if(!e)return null;const n=this.textures.get(e);return void 0===n&&console.error("Non-existent texture ID:",e),n}}var D=t(6382),F=t(4439),z=t(8657).j;i.Object3D.DefaultUp=new i.Vector3(0,0,1);class Y extends D.DOMWidgetModel{defaults(){return F.extend(D.DOMWidgetModel.prototype.defaults.call(this),{_model_name:"OvitoViewportModel",_view_name:"OvitoViewportView",_model_module:"jupyter-ovito",_view_module:"jupyter-ovito",_model_module_version:z,_view_module_version:z,_camera_params:null,_orbit_center:[0,0,0],_scene:{},antialiasing:!0,vr_scale:0,picking:!1})}}class V extends D.DOMWidgetView{render(){try{const n=this;if(!c.isWebGLAvailable())return this.$el.empty().append(c.getWebGLErrorMessage()),this;this.renderer=new i.WebGLRenderer({sortObjects:!1,antialias:this.model.get("antialiasing")}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.xr.enabled=0!==this.model.get("vr_scale"),this.$el.empty().append(this.renderer.domElement),this.el.style.position="relative",this.renderer.domElement.style.width="100%",this.renderer.domElement.style.height="100%",this.renderer.domElement.addEventListener("pointermove",this.onPointerMove.bind(this)),this.renderer.domElement.addEventListener("pointerout",this.onPointerOut.bind(this)),this.statusDisplay=document.createElement("div"),this.statusDisplay.style.cssText="position: absolute; bottom: 0; left: 0; z-index:10000; color: white; pointer-events: none; background-color: rgba(0, 0, 0, .5);",this.$el.append(this.statusDisplay),this.model.on("msg:custom",this.handle_msg,this),this.materials=new M(this.model.get("antialiasing")),this.scene_manager=new E(this.materials,this.renderer),this.orbit_controls=new s(null,this.renderer.domElement),this.orbit_controls.addEventListener("change",this.renderScene.bind(this)),this.orbit_controls.addEventListener("end",this.sendCamera.bind(this)),this.scene_manager.addEventListener("bounding_box_changed",(function(e){n.orbit_controls.updateSceneSizeFactor(e.bounding_box)})),this.camera=new A(this.orbit_controls),this.toolbar=new O,this.el.appendChild(this.toolbar.domElement),(e=this).renderer.xr.enabled&&"xr"in navigator&&navigator.xr.isSessionSupported("immersive-vr").then((function(n){if(!n)return;const t=new i.Mesh(new i.CircleGeometry(.25,32).rotateX(-Math.PI/2),new i.MeshBasicMaterial({color:10518656}));let o;function r(){this.userData.isSelecting=!0}function a(){if(!0===this.userData.isSelecting){t.position.x=0,t.position.z=0,t.visible=!1;const e=(new i.Vector3).setFromMatrixPosition(this.matrix),n=(new i.Vector3).setFromMatrixColumn(this.matrix,2).normalize();n.y*Math.sign(e.y)>.1&&(t.position.x=e.x-n.x/n.y,t.position.z=e.z-n.z/n.y,t.visible=!0)}this.userData.isSqueezing}function s(){if(this.userData.isSelecting=!1,t.visible){t.visible=!1;const n={x:-t.position.x,y:-t.position.y,z:-t.position.z,w:1},r=new i.Quaternion,a=new XRRigidTransform(n,r),s=o.getOffsetReferenceSpace(a);e.renderer.xr.setReferenceSpace(s)}t.position.x=0,t.position.z=0}t.visible=!1,e.scene_manager.vrContainer.add(t),e.renderer.xr.addEventListener("sessionstart",(()=>o=e.renderer.xr.getReferenceSpace()));const c=new G.i;for(let n=0;n<2;n++){const t=e.renderer.xr.getController(n);t.addEventListener("selectstart",r),t.addEventListener("selectend",s),t.addEventListener("move",a),t.addEventListener("connected",(function(e){this.add(C(e.data)),this.children[0].geometry.boundingBox=new i.Box3(new i.Vector3(0,0,-1),new i.Vector3(0,0,0)),this.children[0].frustumCulled=!1})),t.addEventListener("disconnected",(function(){this.children[0].geometry.dispose(),this.remove(this.children[0])})),e.scene_manager.vrContainer.add(t);const o=e.renderer.xr.getControllerGrip(n);o.add(c.createControllerModel(o)),e.scene_manager.vrContainer.add(o)}e.toolbar.addButton("vr_mode",(function(){if(null===e.renderer.xr.getSession()){const n={optionalFeatures:["local-floor","bounded-floor"]};navigator.xr.requestSession("immersive-vr",n).then(e.renderer.xr.setSession.bind(e.renderer.xr))}else e.renderer.xr.getSession().end()}))})),this.toolbar.addButton("zoom_all",this.zoomAll.bind(this)),this.renderer.xr.addEventListener("sessionstart",this.onWebXRSessionStarted.bind(this)),this.renderer.xr.addEventListener("sessionend",this.onWebXRSessionStopped.bind(this)),P(this.model.get("_orbit_center"),n.orbit_controls.target),this.listenTo(this.model,"change:_orbit_center",(function(e,n,t){t&&t.ignore_frontend||P(n)})),this.camera.unpack(this.model.get("_camera_params")),this.listenTo(this.model,"change:_camera_params",(function(e,t,i){i&&i.ignore_frontend||(n.camera.unpack(t),n.renderScene())})),this.scene_manager.unpack(this.model.get("_scene")),this.listenTo(this.model,"change:_scene",(function(e,t,i){n.scene_manager.unpack(t),n.renderScene()}))}catch(e){throw console.error(e),e}var e;return this}remove(){this.teardownRenderer(),super.remove()}teardownRenderer(){this.stopListening(this.model),this.offscreenRenderTarget&&this.offscreenRenderTarget.dispose(),delete this.offscreenRenderTarget,this.materials&&this.materials.dispose(),delete this.materials,this.scene_manager&&this.scene_manager.dispose(),delete this.scene_manager,delete this.orbit_controls,delete this.camera,this.renderer&&(this.renderer.forceContextLoss(),this.renderer.dispose()),delete this.renderer,delete this.toolbar,delete this.pickingBufferUpToDate,this.$el.empty()}sendCamera(){this.model.set("_camera_params",this.camera.pack(),{ignore_frontend:!0}),this.touch()}onWebXRSessionStarted(){this.scene_manager.primitivesContainer.scale.setScalar(this.model.get("vr_scale")),this.scene_manager.primitivesContainer.quaternion.setFromUnitVectors(new i.Vector3(0,0,1),new i.Vector3(0,1,0)),this.scene_manager.primitivesContainer.updateWorldMatrix(!0,!0),this.scene_manager.vrContainer.visible=!0,this.renderer.setAnimationLoop(this.renderScene.bind(this))}onWebXRSessionStopped(){this.renderer.setAnimationLoop(null),this.scene_manager.vrContainer.visible=!1,this.scene_manager.primitivesContainer.scale.setScalar(1),this.scene_manager.primitivesContainer.position.setScalar(0),this.scene_manager.primitivesContainer.quaternion.identity(),this.scene_manager.datasetContainer.scale.setScalar(1),this.scene_manager.datasetContainer.position.setScalar(0),this.scene_manager.datasetContainer.quaternion.identity(),this.scene_manager.datasetContainer.updateWorldMatrix(!0,!0),setTimeout(this.renderScene.bind(this))}zoomAll(){this.camera.zoomToBox(this.scene_manager.getBoundingBox()),this.sendCamera(),this.renderScene()}renderScene(){const e=this.el.clientWidth,n=this.el.clientHeight;if(e&&n&&this.camera.isValid()){let t;!0===this.renderer.xr.isPresenting?(t=this.scene_manager.vrCamera,t.matrix.copy(this.renderer.xr.getCamera().matrix)):(t=this.camera.camera,this.renderer.setDrawingBufferSize(e,n,window.devicePixelRatio),this.pickingBufferUpToDate=!1,this.onHoverObject(void 0)),A.computeProjectionParameters(this.scene_manager.getBoundingBox(),e/n,t),this.renderer.setClearColor(new i.Color(0,0,0),1),this.renderer.render(this.scene_manager.scene,t)}}renderPickingBuffer(){console.assert(this.model.picking);const e=this.renderer.getDrawingBufferSize(new i.Vector2);return!!(e.x&&e.y&&this.camera.isValid())&&(void 0===this.offscreenRenderTarget?this.offscreenRenderTarget=new i.WebGLRenderTarget(e.x,e.y):this.offscreenRenderTarget.width===e.x&&this.offscreenRenderTarget.height===e.y||this.offscreenRenderTarget.setSize(e.x,e.y),this.renderer.setRenderTarget(this.offscreenRenderTarget),this.renderer.setClearColor(new i.Color(0),0),this.camera.camera.layers.set(1),this.renderer.render(this.scene_manager.scene,this.camera.camera),this.camera.camera.layers.set(0),this.renderer.readRenderTargetPixels(this.offscreenRenderTarget),this.renderer.setRenderTarget(null),this.pickingBufferUpToDate=!0,!0)}pickObject(e,n){if(!this.model.picking)return null;if(!0!==this.pickingBufferUpToDate){if(!this.renderPickingBuffer())return null;console.assert(!0===this.pickingBufferUpToDate)}const t=new Uint8Array(4);return this.renderer.readRenderTargetPixels(this.offscreenRenderTarget,e,n,1,1,t),new Uint32Array(t.buffer)[0]}onHoverObject(e){e!==this.current_hover_object_id&&(this.current_hover_object_id=e,e?this.send({event:"hover_object",object_id:e}):this.statusDisplay.textContent="")}onPointerMove(e){const n=e.target.getBoundingClientRect(),t=this.renderer.getPixelRatio(),i=t*(e.clientX-n.left),o=t*(n.bottom-e.clientY),r=this.pickObject(i,o);this.onHoverObject(r)}onPointerOut(e){this.onHoverObject(0)}handle_msg(e){if("hover_object"===e.type&&this.current_hover_object_id===e.object_id){const n=e.text.replaceAll("<sep>",' <font color="gray">|</font> ').replaceAll("<key>",'<font color="#AAFFFF">').replaceAll("</key>","</font>").replaceAll("<val>","").replaceAll("</val>","");this.statusDisplay.innerHTML=n}}processPhosphorMessage(e){super.processPhosphorMessage(e),"resize"===e.type&&window.requestAnimationFrame(this.renderScene.bind(this))}processLuminoMessage(e){super.processLuminoMessage(e),"resize"===e.type&&window.requestAnimationFrame(this.renderScene.bind(this))}}},8743:(e,n,t)=>{"use strict";t.d(n,{Z:()=>s});var i=t(8081),o=t.n(i),r=t(3645),a=t.n(r)()(o());a.push([e.id,".jupyter-ovito {\n    width: auto;\n    height: auto;\n    flex: 1 1 auto;\n}\n\n.jupyter-ovito-toolbtn {\n    width: 30px;\n    height: 30px;\n    border: 0px;\n    display: inline-block;\n    vertical-align: middle;\n    background-color: transparent;\n    background-repeat: no-repeat;\n    background-position: center;\n    padding: 0px;\n}\n\n.jupyter-ovito-toolbtn:hover {\n    background-color: #9a9a9a7a;\n}",""]);const s=a},5418:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n\nvarying vec4 color_fs;\nvarying vec2 uv_fs;\n\nvoid main()\n{\n\t// Test if fragment is within the unit circle.\n\tfloat rsq = dot(uv_fs, uv_fs);\n\tif(rsq >= 1.0) discard;\n\n    outputFlat(color_fs);\n}'},8135:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( OBJECT_PICKING_MODE )\n\nuniform int picking_base_id;\n\nvec4 pickingModeColor(in int primitiveID)\n{\n\t// Compute color from object ID.\n\tint objectID = picking_base_id + primitiveID;\n\n\treturn vec4(\n\t\tfloat(objectID & 0xFF) / 255.0,\n\t\tfloat((objectID >> 8) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 16) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 24) & 0xFF) / 255.0);\n}\n\n#endif\n\nattribute float radius;\n\nvarying vec4 color_fs;\nvarying vec2 uv_fs;\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#elif defined( OBJECT_PICKING_MODE )\n    color_fs = pickingModeColor(gl_VertexID / 4);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    // The index of the quad corner.\n    int corner = gl_VertexID % 4;\n\n    vec2 dir;\n    if(corner == 0) dir = vec2(-1, -1);\n    else if(corner == 1) dir = vec2(1, -1);\n    else if(corner == 2) dir = vec2(1, 1);\n    else dir = vec2(-1, 1);\n    uv_fs = dir;\n\n    // Transform particle center to view space.\n\tvec3 eye_position = (modelViewMatrix * vec4(position, 1.0)).xyz;\n\n    // Apply additional scaling due to model-view transformation to particle radius.\n    float viewspace_radius = radius * length(modelViewMatrix[0]);\n\n\t// Project corner vertex.\n    gl_Position = projectionMatrix * (vec4(eye_position, 1.0) + vec4(dir * viewspace_radius, 0.0, 0.0));\n}'},8686:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n\nvarying vec4 color_fs;\nvarying vec2 uv_fs;\n\nvoid main()\n{\n\t// Calculate distance from the circle\'s center.\n\tfloat rsq = dot(uv_fs, uv_fs);\n\tfloat r = sqrt(rsq);\n\n\t// For antialiasing, calculate alpha value close to the edge of the circle.\n\tfloat afwidth = fwidth(r);\n\tfloat edge = smoothstep(1.0 - afwidth, 1.0, r);\n\tfloat alpha = 1.0 - edge;\n\n\toutputFlat(vec4(color_fs.rgb, color_fs.a * alpha));\n}'},5235:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nvarying vec4 color_fs;\n#if !defined( OBJECT_PICKING_MODE )\n    varying vec3 normal_fs;\n#endif\n\nvoid main()\n{\n#if !defined( OBJECT_PICKING_MODE )\n    vec3 ray_dir_norm = raycasting_fragment();\n    outputShadedRay(color_fs, normal_fs, ray_dir_norm);\n#else\n    outputFlat(color_fs);\n#endif\n}'},637:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment.\nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix);\n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( OBJECT_PICKING_MODE )\n\nuniform int picking_base_id;\n\nvec4 pickingModeColor(in int primitiveID)\n{\n\t// Compute color from object ID.\n\tint objectID = picking_base_id + primitiveID;\n\n\treturn vec4(\n\t\tfloat(objectID & 0xFF) / 255.0,\n\t\tfloat((objectID >> 8) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 16) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 24) & 0xFF) / 255.0);\n}\n\n#endif\n\nvarying vec4 color_fs;\n#if !defined( OBJECT_PICKING_MODE )\n    varying vec3 normal_fs;\n#endif\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#elif defined( OBJECT_PICKING_MODE )\n    color_fs = pickingModeColor(gl_VertexID / 24);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n#if !defined( OBJECT_PICKING_MODE )\n    normal_fs = normalize(normalMatrix * normal);\n    raycasting_vertex();\n#endif\n}'},8132:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n\nvarying vec4 color_fs;\n\nvoid main()\n{\n    outputFlat(color_fs);\n}'},7298:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( OBJECT_PICKING_MODE )\n\nuniform int picking_base_id;\n\nvec4 pickingModeColor(in int primitiveID)\n{\n\t// Compute color from object ID.\n\tint objectID = picking_base_id + primitiveID;\n\n\treturn vec4(\n\t\tfloat(objectID & 0xFF) / 255.0,\n\t\tfloat((objectID >> 8) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 16) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 24) & 0xFF) / 255.0);\n}\n\n#endif\n\nattribute vec3 base;\nattribute vec3 head;\nattribute float radius;\n#if !defined( OBJECT_PICKING_MODE )\n    attribute vec4 color1;\n    attribute vec4 color2;\n#endif\n\nvarying vec4 color_fs;\n\nvoid main()\n{\n#if !defined( OBJECT_PICKING_MODE )\n    // Forward arrow color to fragment shader.\n    color_fs = color1;\n#else\n    color_fs = pickingModeColor(gl_VertexID / 7);\n#endif\n\n    // Arrow in view space.\n    vec3 base_view = (modelViewMatrix * vec4(base, 1.0)).xyz;\n    vec3 head_view = (modelViewMatrix * vec4(head, 1.0)).xyz;\n\n    // Vector pointing from camera to cylinder base in view space:\n\tvec3 view_dir;\n\tif(isOrthographic) {\n\t\tview_dir = vec3(0,0,1);\n    }\n\telse {\n\t\tview_dir = (viewMatrix * vec4(cameraPosition, 1.0)).xyz - base_view;\n    }\n\n    // Arrow radius in view space.\n    float radius_view = radius * length(modelViewMatrix[0]);\n\n\t// Build local coordinate system in view space.\n    mat3 uv_tm;\n\tuv_tm[0] = head_view - base_view;\n    uv_tm[1] = normalize(cross(view_dir, uv_tm[0])) * radius_view;\n    uv_tm[2] = vec3(0);\n\n    vec2 vpos;\n    float arrowHeadRadius = 2.5;\n    float arrowHeadLength = (radius_view * arrowHeadRadius * 1.8) / length(uv_tm[0]);\n    int vidx = gl_VertexID % 7;\n    if(arrowHeadLength < 1.0) {\n        if(vidx == 0) vpos = vec2(1.0, 0.0);\n        else if(vidx == 1) vpos = vec2(1.0 - arrowHeadLength, arrowHeadRadius);\n        else if(vidx == 2) vpos = vec2(1.0 - arrowHeadLength, 1.0);\n        else if(vidx == 3) vpos = vec2(0.0, 1.0);\n        else if(vidx == 4) vpos = vec2(0.0,-1.0);\n        else if(vidx == 5) vpos = vec2(1.0 - arrowHeadLength, -1.0);\n        else if(vidx == 6) vpos = vec2(1.0 - arrowHeadLength, -arrowHeadRadius);\n    }\n    else {\n        if(vidx == 0) vpos = vec2(1.0, 0.0);\n        else if(vidx == 1) vpos = vec2(0.0, arrowHeadRadius / arrowHeadLength);\n        else if(vidx == 6) vpos = vec2(0.0,-arrowHeadRadius / arrowHeadLength);\n        else vpos = vec2(0.0, 0.0);\n    }\n\n\t// Project corner vertex.\n    gl_Position = projectionMatrix * vec4(base_view + uv_tm * vec3(vpos, 0.0), 1.0);\n}'},6115:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nvarying vec4 color_fs;\nvarying vec3 center;\t// Transformed cone vertex in view coordinates\nvarying vec3 axis;\t\t// Transformed cone axis in view coordinates\nvarying float cone_radius;\t// The radius of the cone\n\nconst float cone_ratio = 1.8; // Ratio of height to radius of arrow head code.\nconst float cone_angle = atan(1.0 / cone_ratio);\nconst float cone_cos_squared = cos(cone_angle) * cos(cone_angle); // squared cosine of the cone angle\n\nvoid main()\n{\n    vec3 ray_dir_norm = raycasting_fragment();\n\n\tfloat zmin;\n\tvec3 ray_origin_shifted = ray_origin;\n\t// This is to improve numeric precision of intersection calculation:\n\tif(isOrthographic) {\n\t\tzmin = dot(ray_dir_norm, ray_origin - center);\n\t\tray_origin_shifted.z = center.z;\n\t}\n\telse {\n\t\tzmin = -cone_radius * cone_ratio;\n\t\tray_origin_shifted += ray_dir_norm * dot(ray_dir_norm, center - ray_origin);\n\t}\n\n\tvec3 axis_normed = normalize(axis);\n\tfloat AdD = dot(axis_normed, ray_dir_norm);\n\tvec3 E = ray_origin_shifted - center;\n\tfloat AdE = dot(axis_normed, E);\n\tfloat DdE = dot(ray_dir_norm, E);\n\tfloat EdE = dot(E, E);\n\tfloat c2 = AdD*AdD - cone_cos_squared;\n\tfloat c1 = AdD*AdE - cone_cos_squared*DdE;\n\tfloat c0 = AdE*AdE - cone_cos_squared*EdE;\n\n\t// Solve the quadratic. Keep only those X for which dot(A,X-V) >= 0.\n\tfloat ray_t = zmin;\n\n\tfloat epsilon = 1e-9 * cone_radius * cone_radius;\n\tif(abs(c2) >= epsilon) {\n\t\tfloat discr = c1*c1 - c0*c2;\n\t\tif(discr < -epsilon) {\n\t\t\t// Q(t) = 0 has no real-valued roots. The ray does not\n\t\t\t// intersect the double-sided cone.\n\t\t\tdiscard;\n\t\t}\n\t\telse if(discr > epsilon) {\n\t\t\t// Q(t) = 0 has two distinct real-valued roots.  However, one or\n\t\t\t// both of them might intersect the portion of the double-sided\n\t\t\t// cone "behind" the vertex.  We are interested only in those\n\t\t\t// intersections "in front" of the vertex.\n\t\t\tfloat root = sqrt(discr);\n\t\t\tfloat height_sq = dot(axis, axis);\n\t\t\tfloat t = (-c1 - root) / c2;\n\t\t\tE = ray_origin_shifted + t * ray_dir_norm - center;\n\t\t\tfloat ddot = dot(E, axis);\n\t\t\tif(ddot > 0.0 && ddot < height_sq && t > zmin) {\n\t\t\t\tray_t = t;\n\t\t\t}\n\t\t\tt = (-c1 + root) / c2;\n\t\t\tvec3 E2 = ray_origin_shifted + t * ray_dir_norm - center;\n\t\t\tddot = dot(E2, axis);\n\t\t\tif(ddot > 0.0 && ddot < height_sq && t > zmin) {\n\t\t\t\tray_t = t;\n\t\t\t\tE = E2;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// One repeated real root (line is tangent to the cone).\n\t\t\tfloat t = -(c1/c2);\n\t\t\tE = ray_origin_shifted + t * ray_dir_norm - center;\n\t\t\tif(dot(E, axis) > 0.0) {\n\t\t\t\tray_t = t;\n\t\t\t}\n\t\t}\n\t}\n\telse if(abs(c1) >= epsilon) {\n\t\t// c2 = 0, c1 != 0 (D is a direction vector on the cone boundary)\n\t\tfloat t = -(0.5*c0/c1);\n\t\tE = ray_origin_shifted + t * ray_dir_norm - center;\n\t\tif(dot(E, axis) > 0.0) {\n\t\t\tray_t = t;\n\t\t}\n\t}\n\telse if(abs(c0) >= epsilon) {\n\t\t// c2 = c1 = 0, c0 != 0\n\t\tdiscard;\n\t}\n\telse if(DdE > 0.0) {\n\t\t// c2 = c1 = c0 = 0, cone contains ray V+t*D where V is cone vertex\n\t\t// and D is the line direction.\n\t\tray_t = DdE;\n\t}\n\tif(ray_t <= zmin)\n\t\tdiscard;\n\n\t// Intersection point with cone:\n\tvec3 view_intersection_pnt = E + center;\n\t// Surface normal at cone intersection point:\n\tvec3 surface_normal = cross(E, cross(E, axis));\n\n\t// Compute intersection with disc.\n\tvec3 disc_center = center + axis;\n\tvec3 normal = axis;\n\tfloat d = -dot(disc_center, normal);\n\tfloat t = -(d + dot(normal, ray_origin_shifted));\n\tfloat td = dot(normal, ray_dir_norm);\n\tt /= td;\n\tif(/*t > zmin && */t < ray_t) {\n\t\tvec3 hitpnt = ray_origin_shifted + t * ray_dir_norm - disc_center;\n\t\tif(dot(hitpnt,hitpnt) < cone_radius*cone_radius) {\n\t\t\tview_intersection_pnt = ray_origin_shifted + t * ray_dir_norm;\n\t\t\tsurface_normal = normal;\n\t\t}\n\t}\n\n\t// Output the ray-cylinder intersection point as the fragment depth\n\t// rather than the depth of the bounding box polygons.\n\t// The eye coordinate Z value must be transformed to normalized device\n\t// coordinates before being assigned as the final fragment depth.\n\tvec4 projected_intersection = projectionMatrix * vec4(view_intersection_pnt, 1.0);\n\tfloat zdepth = (projected_intersection.z / projected_intersection.w + 1.0) * 0.5;\n\n#if !defined( OBJECT_PICKING_MODE )\n    // Calculate surface normal in view coordinate system.\n    outputShadedRayAndDepth(color_fs, normalize(surface_normal), ray_dir_norm, zdepth);\n#else\n\toutputFlatAndDepth(color_fs, zdepth);\n#endif\n}'},8799:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment.\nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix);\n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( OBJECT_PICKING_MODE )\n\nuniform int picking_base_id;\n\nvec4 pickingModeColor(in int primitiveID)\n{\n\t// Compute color from object ID.\n\tint objectID = picking_base_id + primitiveID;\n\n\treturn vec4(\n\t\tfloat(objectID & 0xFF) / 255.0,\n\t\tfloat((objectID >> 8) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 16) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 24) & 0xFF) / 255.0);\n}\n\n#endif\n\nattribute vec3 base;\nattribute vec3 head;\nattribute float radius;\n#if !defined( OBJECT_PICKING_MODE )\n    attribute vec4 color1;\n    attribute vec4 color2;\n#endif\n\nvarying vec4 color_fs;\nvarying vec3 center;\t// Transformed cone vertex in view coordinates\nvarying vec3 axis;\t\t// Transformed cone axis in view coordinates\nvarying float cone_radius;\t// The radius of the cone\n\nconst float cone_ratio = 1.8; // Ratio of height to radius of arrow head code.\n\nvoid main()\n{\n#if !defined( OBJECT_PICKING_MODE )\n    // Forward arrow color to fragment shader.\n    color_fs = color1;\n#else\n    color_fs = pickingModeColor(gl_VertexID / 24);\n#endif\n\n    float arrowHeadRadius = 2.5;\n    float arrowHeadLength = cone_ratio * radius * arrowHeadRadius;\n\n    // Reduce original cylinder height to arrow tail length.\n    vec3 vpos = position;\n\n    vec3 arrow_axis = head - base;\n    float len = length(arrow_axis);\n    if(len != 0.0) {\n        if(arrowHeadLength > len) {\n            arrowHeadRadius *= len / arrowHeadLength;\n            arrowHeadLength = len;\n        }\n\n        float h = dot(head - position, arrow_axis) / dot(arrow_axis, arrow_axis);\n        vec3 inplane = (position - base - arrow_axis * (1.0 - h));\n        if(h > 0.5)\n            vpos += (arrowHeadRadius - 1.0) * inplane;\n        else\n            vpos -= inplane;\n\n        float len_offset = (1.0 - arrowHeadLength / len);\n        vpos += arrow_axis * (len_offset * h);\n        arrow_axis *= arrowHeadLength / len;\n    }\n    arrowHeadRadius *= radius;\n\n    // Apply model-view-projection matrix to box vertex position.\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(vpos, 1.0);\n\n    // Apply additional scaling to cone radius due to model-view transformation.\n\t// Pass square of cylinder radius to fragment shader.\n    cone_radius = arrowHeadRadius * length(modelViewMatrix[0]);\n\n\t// Transform cone to eye coordinates.\n    center = (modelViewMatrix * vec4(head, 1.0)).xyz;\n    axis = (modelViewMatrix * vec4(-arrow_axis, 0.0)).xyz;\n\n    raycasting_vertex();\n}'},4644:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment.\nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix);\n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( OBJECT_PICKING_MODE )\n\nuniform int picking_base_id;\n\nvec4 pickingModeColor(in int primitiveID)\n{\n\t// Compute color from object ID.\n\tint objectID = picking_base_id + primitiveID;\n\n\treturn vec4(\n\t\tfloat(objectID & 0xFF) / 255.0,\n\t\tfloat((objectID >> 8) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 16) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 24) & 0xFF) / 255.0);\n}\n\n#endif\n\nattribute vec3 base;\nattribute vec3 head;\nattribute float radius;\n#if !defined( OBJECT_PICKING_MODE )\n    attribute vec4 color1;\n    attribute vec4 color2;\n#endif\n\n#if !defined( OBJECT_PICKING_MODE )\n    varying vec4 color1_fs;\n    varying vec4 color2_fs;\n#else\n\tvarying vec4 color_fs;\n#endif\nvarying vec3 cylinder_view_base;\t\t// Transformed cylinder position in view coordinates\nvarying vec3 cylinder_view_axis;\t\t// Transformed cylinder axis in view coordinates\nvarying float cylinder_radius_sq_fs;\t// The squared radius of the cylinder\nvarying float cylinder_length;\t\t\t// The length of the cylinder\n\nconst float cone_ratio = 1.8; // Ratio of height to radius of arrow head code.\n\nvoid main()\n{\n#if !defined( OBJECT_PICKING_MODE )\n    // Forward cylinder colors to fragment shader.\n    color1_fs = color1;\n    color2_fs = color2;\n#else\n    color_fs = pickingModeColor(gl_VertexID / 24);\n#endif\n\n    float arrowHeadRadius = radius * 2.5;\n    float arrowHeadLength = cone_ratio * arrowHeadRadius;\n\n    // Reduce original cylinder height to arrow tail length.\n    vec3 vpos = position;\n\n    vec3 arrow_axis = head - base;\n    float len = length(arrow_axis);\n    if(len != 0.0) {\n        if(arrowHeadLength > len)\n            arrowHeadLength = len;\n        vpos -= arrow_axis * (arrowHeadLength / len * dot(position - base, arrow_axis) / dot(arrow_axis, arrow_axis));\n        arrow_axis *= (1.0 - arrowHeadLength / len);\n    }\n\n    // Apply model-view-projection matrix to box vertex position.\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(vpos, 1.0);\n\n    // Apply additional scaling to cylinder radius due to model-view transformation.\n    float viewspace_radius = radius * length(modelViewMatrix[0]);\n\n\t// Pass square of cylinder radius to fragment shader.\n\tcylinder_radius_sq_fs = viewspace_radius * viewspace_radius;\n\n\t// Transform cylinder to eye coordinates.\n\tcylinder_view_base = (modelViewMatrix * vec4(base, 1.0)).xyz;\n\tcylinder_view_axis = (modelViewMatrix * vec4(arrow_axis, 0.0)).xyz;\n\n\t// Pass cylinder length to fragment shader.\n\tcylinder_length = length(cylinder_view_axis);\n\n    raycasting_vertex();\n}'},2293:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nconst int single_cylinder_cap = SINGLE_CYLINDER_CAP;\n\n#if !defined( OBJECT_PICKING_MODE )\n\tvarying vec4 color1_fs;\n\tvarying vec4 color2_fs;\n#else\n\tvarying vec4 color_fs;\n#endif\nvarying vec3 cylinder_view_base;\t\t// Transformed cylinder position in view coordinates\nvarying vec3 cylinder_view_axis;\t\t// Transformed cylinder axis in view coordinates\nvarying float cylinder_radius_sq_fs;\t// The squared radius of the cylinder\nvarying float cylinder_length;\t\t\t// The length of the cylinder\n\n#ifdef USE_PSEUDOCOLORS\nuniform sampler2D color_map;\n#endif\n\nvoid main()\n{\n    vec3 ray_dir_norm = raycasting_fragment();\n\n\t// Perform ray-cylinder intersection test.\n\tvec3 n = cross(ray_dir_norm, cylinder_view_axis);\n\tfloat ln = length(n);\n\tvec3 RC = ray_origin - cylinder_view_base;\n\n\tvec3 view_intersection_pnt = ray_origin;\n#if !defined( OBJECT_PICKING_MODE )\n\tvec3 surface_normal;\n\tfloat x;\t// Normalized location along cylinder (used for color interpolation).\n#endif\n\n\tbool skip = false;\n\n\tif(ln < 1e-7 * cylinder_length) {\n\t\t// Handle case where view ray is parallel to cylinder axis:\n\n\t\tfloat t = dot(RC, ray_dir_norm);\n\t\tfloat v = dot(RC, RC);\n\t\tif(v-t*t > cylinder_radius_sq_fs) {\n\t\t\tdiscard;\n\t\t}\n\t\telse {\n\t\t\tview_intersection_pnt -= t * ray_dir_norm;\n#if !defined( OBJECT_PICKING_MODE )\n\t\t\tsurface_normal = -cylinder_view_axis;\n#endif\n\t\t\tfloat tfar = dot(cylinder_view_axis, ray_dir_norm);\n\t\t\tif(tfar < 0.0 && single_cylinder_cap == 0) {\n\t\t\t\tview_intersection_pnt += tfar * ray_dir_norm;\n#if !defined( OBJECT_PICKING_MODE )\n\t\t\t\tsurface_normal = cylinder_view_axis;\n\t\t\t\tx = 1.0;\n#endif\n\t\t\t}\n\t\t\telse {\n#if !defined( OBJECT_PICKING_MODE )\n\t\t\t\tx = 0.0;\n#endif\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\n\t\tn /= ln;\n\t\tfloat d = dot(RC,n);\n\t\td *= d;\n\n\t\t// Test if ray missed the cylinder.\n\t\tif(d > cylinder_radius_sq_fs) {\n\t\t\tdiscard;\n\t\t}\n\t\telse {\n\n\t\t\t// Calculate closest intersection position.\n\t\t\tfloat t = dot(cross(cylinder_view_axis, RC), n) / ln;\n\t\t\tfloat s = abs(sqrt(cylinder_radius_sq_fs - d) / dot(cross(n, cylinder_view_axis), ray_dir_norm) * cylinder_length);\n\t\t\tfloat tnear = t - s;\n\n\t\t\t// Calculate intersection point in view coordinate system.\n\t\t\tview_intersection_pnt += tnear * ray_dir_norm;\n\n\t\t\t// Find intersection position along cylinder axis.\n\t\t\tfloat anear = dot(view_intersection_pnt - cylinder_view_base, cylinder_view_axis) / (cylinder_length*cylinder_length);\n\t\t\tif(anear >= 0.0 && anear <= 1.0) {\n\n#if !defined( OBJECT_PICKING_MODE )\n\t\t\t\t// Calculate surface normal in view coordinate system.\n\t\t\t\tsurface_normal = (view_intersection_pnt - (cylinder_view_base + anear * cylinder_view_axis));\n\t\t\t\tx = anear;\n#endif\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Calculate second intersection point.\n\t\t\t\tfloat tfar = t + s;\n\t\t\t\tvec3 far_view_intersection_pnt = ray_origin + tfar * ray_dir_norm;\n\t\t\t\tfloat afar = dot(far_view_intersection_pnt - cylinder_view_base, cylinder_view_axis) / (cylinder_length*cylinder_length);\n\n\t\t\t\t// Compute intersection with cylinder caps.\n\t\t\t\tif(anear < 0.0 && afar > 0.0) {\n\t\t\t\t\tview_intersection_pnt += (anear / (anear - afar) * 2.0 * s + 1e-6 * ln) * ray_dir_norm;\n#if !defined( OBJECT_PICKING_MODE )\n\t\t\t\t\tsurface_normal = -cylinder_view_axis;\n\t\t\t\t\tx = 0.0;\n#endif\n\t\t\t\t}\n\t\t\t\telse if(anear > 1.0 && afar < 1.0 && single_cylinder_cap == 0) {\n\t\t\t\t\tview_intersection_pnt += ((anear - 1.0) / (anear - afar) * 2.0 * s + 1e-6 * ln) * ray_dir_norm;\n#if !defined( OBJECT_PICKING_MODE )\n\t\t\t\t\tsurface_normal = cylinder_view_axis;\n\t\t\t\t\tx = 1.0;\n#endif\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Output the ray-cylinder intersection point as the fragment depth\n\t// rather than the depth of the bounding box polygons.\n\t// The eye coordinate Z value must be transformed to normalized device\n\t// coordinates before being assigned as the final fragment depth.\n\tvec4 projected_intersection = projectionMatrix * vec4(view_intersection_pnt, 1.0);\n\tfloat zdepth = (projected_intersection.z / projected_intersection.w + 1.0) * 0.5;\n\n#if !defined( OBJECT_PICKING_MODE )\n\t// Perform linear interpolation of color.\n\tvec4 color = mix(color1_fs, color2_fs, x);\n\n\t// If pseudocolor mapping is used, apply tabulated transfer function to pseudocolor value,\n\t// which is stored in the R component of the input color.\n#ifdef USE_PSEUDOCOLORS\n\tcolor.rgb = texture2D(color_map, color.xy).xyz;\n#endif\n\n    // Calculate surface normal in view coordinate system.\n    outputShadedRayAndDepth(color, normalize(surface_normal), ray_dir_norm, zdepth);\n#else\n    outputFlatAndDepth(color_fs, zdepth);\n#endif\n}'},3568:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment.\nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix);\n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( OBJECT_PICKING_MODE )\n\nuniform int picking_base_id;\n\nvec4 pickingModeColor(in int primitiveID)\n{\n\t// Compute color from object ID.\n\tint objectID = picking_base_id + primitiveID;\n\n\treturn vec4(\n\t\tfloat(objectID & 0xFF) / 255.0,\n\t\tfloat((objectID >> 8) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 16) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 24) & 0xFF) / 255.0);\n}\n\n#endif\n\nattribute vec3 base;\nattribute vec3 head;\nattribute float radius;\n\n#if !defined( OBJECT_PICKING_MODE )\n    attribute vec4 color1;\n    attribute vec4 color2;\n\tvarying vec4 color1_fs;\n\tvarying vec4 color2_fs;\n#else\n\tvarying vec4 color_fs;\n#endif\nvarying vec3 cylinder_view_base;\t\t// Transformed cylinder position in view coordinates\nvarying vec3 cylinder_view_axis;\t\t// Transformed cylinder axis in view coordinates\nvarying float cylinder_radius_sq_fs;\t// The squared radius of the cylinder\nvarying float cylinder_length;\t\t\t// The length of the cylinder\n\n#ifdef USE_PSEUDOCOLORS\nuniform float color_range_min;\nuniform float color_range_max;\n#endif\n\nvoid main()\n{\n#if !defined( OBJECT_PICKING_MODE )\n    // Forward cylinder colors to fragment shader.\n    color1_fs = color1;\n    color2_fs = color2;\n#else\n    color_fs = pickingModeColor(gl_VertexID / 24);\n#endif\n\n#ifdef USE_PSEUDOCOLORS\n    color1_fs.x = (color1_fs.x - color_range_min) / (color_range_max - color_range_min);\n    color2_fs.x = (color2_fs.x - color_range_min) / (color_range_max - color_range_min);\n#endif\n\n    // Apply model-view-projection matrix to box vertex position.\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    // Apply additional scaling to cylinder radius due to model-view transformation.\n    float viewspace_radius = radius * length(modelViewMatrix[0]);\n\n\t// Pass square of cylinder radius to fragment shader.\n\tcylinder_radius_sq_fs = viewspace_radius * viewspace_radius;\n\n\t// Transform cylinder to eye coordinates.\n\tcylinder_view_base = (modelViewMatrix * vec4(base, 1.0)).xyz;\n\tcylinder_view_axis = (modelViewMatrix * vec4(head - base, 0.0)).xyz;\n\n\t// Pass cylinder length to fragment shader.\n\tcylinder_length = length(cylinder_view_axis);\n\n    raycasting_vertex();\n}'},6456:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n\nvarying vec4 color_fs;\n\n#ifdef USE_PSEUDOCOLORS\nuniform sampler2D color_map;\n#endif\n\nvoid main()\n{\n#ifndef USE_PSEUDOCOLORS\n    outputFlat(color_fs);\n#else\n\t// If pseudocolor mapping is used, apply tabulated transfer function to pseudocolor value,\n\t// which is stored in the R component of the input color.\n\toutputFlat(texture2D(color_map, color_fs.xy));\n#endif\n}'},8591:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( OBJECT_PICKING_MODE )\n\nuniform int picking_base_id;\n\nvec4 pickingModeColor(in int primitiveID)\n{\n\t// Compute color from object ID.\n\tint objectID = picking_base_id + primitiveID;\n\n\treturn vec4(\n\t\tfloat(objectID & 0xFF) / 255.0,\n\t\tfloat((objectID >> 8) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 16) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 24) & 0xFF) / 255.0);\n}\n\n#endif\n\nattribute vec3 base;\nattribute vec3 head;\nattribute float radius;\n#if !defined( OBJECT_PICKING_MODE )\n    attribute vec4 color1;\n    attribute vec4 color2;\n#endif\n\nvarying vec4 color_fs;\n\n#ifdef USE_PSEUDOCOLORS\n    uniform float color_range_min;\n    uniform float color_range_max;\n#endif\n\nvoid main()\n{\n#if !defined( OBJECT_PICKING_MODE )\n    // Forward color to fragment shader.\n    color_fs = color1;\n#else\n    color_fs = pickingModeColor(gl_VertexID / 4);\n#endif\n\n#ifdef USE_PSEUDOCOLORS\n    color_fs.x = (color_fs.x - color_range_min) / (color_range_max - color_range_min);\n#endif\n\n    // Arrow in view space.\n    vec3 base_view = (modelViewMatrix * vec4(base, 1.0)).xyz;\n    vec3 head_view = (modelViewMatrix * vec4(head, 1.0)).xyz;\n\n    // Vector pointing from camera to cylinder base in view space:\n\tvec3 view_dir;\n\tif(isOrthographic) {\n\t\tview_dir = vec3(0,0,1);\n    }\n\telse {\n\t\tview_dir = (viewMatrix * vec4(cameraPosition, 1.0)).xyz - base_view;\n    }\n\n    // Arrow radius in view space.\n    float radius_view = radius * length(modelViewMatrix[0]);\n\n\t// Build local coordinate system in view space.\n    mat3 uv_tm;\n\tuv_tm[0] = head_view - base_view;\n    uv_tm[1] = normalize(cross(view_dir, uv_tm[0])) * radius_view;\n    uv_tm[2] = vec3(0);\n\n    vec2 vpos;\n    int vidx = gl_VertexID % 4;\n    if(vidx == 0) vpos = vec2(1.0, -1.0);\n    else if(vidx == 1) vpos = vec2(1.0, 1.0);\n    else if(vidx == 2) vpos = vec2(0.0, 1.0);\n    else vpos = vec2(0.0, -1.0);\n\n\t// Project corner vertex.\n    gl_Position = projectionMatrix * vec4(base_view + uv_tm * vec3(vpos, 0.0), 1.0);\n}'},4617:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nvarying vec4 color_fs;\nvarying mat3 view_to_sphere_fs;\nvarying mat3 sphere_to_view_fs;\nvarying vec3 particle_view_pos_fs;\n\nvoid main()\n{\n    vec3 ray_dir_norm = raycasting_fragment();\n\tvec3 sphere_dir = view_to_sphere_fs * (particle_view_pos_fs - ray_origin);\n\n\t// Ray direction in sphere coordinate system.\n\tvec3 ray_dir2 = normalize(view_to_sphere_fs * ray_dir);\n\n\t// Perform ray-sphere intersection test.\n\tfloat b = dot(ray_dir2, sphere_dir);\n\tvec3 delta = ray_dir2 * b - sphere_dir;\n\tfloat x = dot(delta, delta);\n\tfloat disc = 1.0 - x;\n\n\t// Only calculate the intersection closest to the viewer.\n\tif(disc < 0.0)\n\t\tdiscard; // Ray missed sphere entirely, discard fragment\n\n\t// Calculate closest intersection position.\n\tfloat tnear = b - sqrt(disc);\n\n\t// Calculate intersection point in sphere coordinate system.\n\tvec3 sphere_intersection_pnt = tnear * ray_dir2 - sphere_dir;\n\n\t// Calculate intersection point in view coordinate system.\n    vec3 view_intersection_pnt = sphere_to_view_fs * sphere_intersection_pnt + particle_view_pos_fs;\n\n\t// Output the ray-sphere intersection point as the fragment depth\n\t// rather than the depth of the bounding box polygons.\n\t// The eye coordinate Z value must be transformed to normalized device\n\t// coordinates before being assigned as the final fragment depth.\n\tvec4 projected_intersection = projectionMatrix * vec4(view_intersection_pnt, 1.0);\n\tfloat zdepth = (projected_intersection.z / projected_intersection.w + 1.0) * 0.5;\n\n#if !defined( OBJECT_PICKING_MODE )\n    // Calculate surface normal in view coordinate system.\n    vec3 surface_normal = normalize(sphere_intersection_pnt * view_to_sphere_fs);\n    outputShadedRayAndDepth(color_fs, surface_normal, ray_dir_norm, zdepth);\n#else\n    outputFlatAndDepth(color_fs, zdepth);\n#endif\n}'},2322:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment.\nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix);\n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( OBJECT_PICKING_MODE )\n\nuniform int picking_base_id;\n\nvec4 pickingModeColor(in int primitiveID)\n{\n\t// Compute color from object ID.\n\tint objectID = picking_base_id + primitiveID;\n\n\treturn vec4(\n\t\tfloat(objectID & 0xFF) / 255.0,\n\t\tfloat((objectID >> 8) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 16) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 24) & 0xFF) / 255.0);\n}\n\n#endif\n\nattribute mat4 shape_orientation;\n\nvarying vec4 color_fs;\nvarying mat3 view_to_sphere_fs;\nvarying mat3 sphere_to_view_fs;\nvarying vec3 particle_view_pos_fs;\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#elif defined( OBJECT_PICKING_MODE )\n    color_fs = pickingModeColor(gl_VertexID / 24);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    // Pass particle center position to fragment shader.\n\tparticle_view_pos_fs = (modelViewMatrix * shape_orientation[3]).xyz;\n\n    // Matrices for converting to/from unit sphere space.\n    sphere_to_view_fs = mat3(modelViewMatrix) * mat3(shape_orientation);\n    view_to_sphere_fs = inverse(sphere_to_view_fs);\n\n    raycasting_vertex();\n}'},7836:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n\nvarying vec4 color_fs;\n\nvoid main()\n{\n    outputFlat(color_fs);\n}'},9439:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( OBJECT_PICKING_MODE )\n\nuniform int picking_base_id;\n\nvec4 pickingModeColor(in int primitiveID)\n{\n\t// Compute color from object ID.\n\tint objectID = picking_base_id + primitiveID;\n\n\treturn vec4(\n\t\tfloat(objectID & 0xFF) / 255.0,\n\t\tfloat((objectID >> 8) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 16) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 24) & 0xFF) / 255.0);\n}\n\n#endif\n\nuniform vec2 line_thickness;\n\nattribute vec3 position2;\n\nvarying vec4 color_fs;\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#elif defined( OBJECT_PICKING_MODE )\n    color_fs = pickingModeColor(gl_VertexID / 4);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    // The index of the quad corner.\n    int corner = gl_VertexID % 4;\n\n    mat4 modelViewProjectionMatrix = projectionMatrix * modelViewMatrix;\n\n\t// Apply model-view-projection matrix to line points.\n\tvec4 proj_from = modelViewProjectionMatrix * vec4(position, 1.0);\n\tvec4 proj_to   = modelViewProjectionMatrix * vec4(position2, 1.0);\n\n\t// Compute line direction vector.\n\tvec2 delta = normalize(proj_to.xy / proj_to.w - proj_from.xy / proj_from.w) * line_thickness;\n\n\t// Correct direction vector if one vertex is behind the viewer the other one in front.\n\tif(proj_to.w * proj_from.w < 0.0)\n\t\tdelta = -delta;\n\n\t// Emit quad vertices.\n\tif(corner == 0)\n\t\tgl_Position = proj_from - vec4(delta.y * proj_from.w, -delta.x * proj_from.w, 0.0, 0.0);\n\telse if(corner == 1)\n\t\tgl_Position = proj_from + vec4(delta.y * proj_from.w, -delta.x * proj_from.w, 0.0, 0.0);\n\telse if(corner == 2)\n\t\tgl_Position = proj_to + vec4(delta.y * proj_to.w, -delta.x * proj_to.w, 0.0, 0.0);\n\telse\n\t\tgl_Position = proj_to - vec4(delta.y * proj_to.w, -delta.x * proj_to.w, 0.0, 0.0);\n}'},7575:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nvarying vec4 color_fs;\n#if !defined( OBJECT_PICKING_MODE )\n    varying vec3 normal_fs;\n#endif\n\n#ifdef USE_PSEUDOCOLORS\nuniform sampler2D color_map;\nuniform float opacity;\nuniform vec3 selection_color;\n#endif\n\nvoid main()\n{\n#if !defined( OBJECT_PICKING_MODE )\n    vec3 ray_dir_norm = raycasting_fragment();\n\n    #ifndef USE_PSEUDOCOLORS\n        outputShadedRay(color_fs, normal_fs, ray_dir_norm);\n    #else\n        if(color_fs.y == 0.0) {\n            vec3 color = texture2D(color_map, color_fs.xy).xyz;\n            outputShadedRay(vec4(color, opacity), normal_fs, ray_dir_norm);\n        }\n        else {\n            outputShadedRay(vec4(selection_color, opacity), normal_fs, ray_dir_norm);\n        }\n    #endif\n#else\n    outputFlat(color_fs);\n#endif\n}'},4484:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment.\nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix);\n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( OBJECT_PICKING_MODE )\n\nuniform int picking_base_id;\n\nvec4 pickingModeColor(in int primitiveID)\n{\n\t// Compute color from object ID.\n\tint objectID = picking_base_id + primitiveID;\n\n\treturn vec4(\n\t\tfloat(objectID & 0xFF) / 255.0,\n\t\tfloat((objectID >> 8) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 16) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 24) & 0xFF) / 255.0);\n}\n\n#endif\n\nvarying vec4 color_fs;\n#if !defined( OBJECT_PICKING_MODE )\n    varying vec3 normal_fs;\n#endif\n\n#ifdef USE_PSEUDOCOLORS\nuniform float color_range_min;\nuniform float color_range_max;\n#endif\n\nvoid main()\n{\n#ifndef USE_INSTANCING_COLOR\n    #if defined( USE_COLOR_ALPHA )\n        color_fs = color;\n    #elif defined( USE_COLOR )\n        color_fs = vec4(color, 1.0);\n    #elif defined( OBJECT_PICKING_MODE )\n        color_fs = pickingModeColor(gl_VertexID / 3);\n    #else\n        color_fs = vec4(1.0);\n    #endif\n#else\n    #if !defined( OBJECT_PICKING_MODE )\n        color_fs = vec4(instanceColor, 1.0);\n    #else\n        color_fs = vec4(instanceColor, 0.0);\n    #endif\n#endif\n\n#ifdef USE_PSEUDOCOLORS\n    color_fs.x = (color_fs.x - color_range_min) / (color_range_max - color_range_min);\n#endif\n\n#ifndef USE_INSTANCING\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n#else\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * instanceMatrix * vec4(position, 1.0);\n#endif\n\n#if !defined( OBJECT_PICKING_MODE )\n    #ifndef USE_INSTANCING\n        normal_fs = normalize(normalMatrix * normal);\n    #else\n        normal_fs = normalize(((viewMatrix * modelMatrix * instanceMatrix) * vec4(normal, 0.0)).xyz);\n    #endif\n    raycasting_vertex();\n#endif\n}'},2735:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n\nuniform vec4 wireframe_color;\n\nvoid main()\n{\n    outputFlat(wireframe_color);\n}'},1717:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvoid main()\n{\n#ifndef USE_INSTANCING\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n#else\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * instanceMatrix * vec4(position, 1.0);\n#endif\n}'},2923:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n\nvarying vec4 color_fs;\nvarying vec2 uv_fs;\n\nvoid main()\n{\n\t// Test if fragment is within the unit circle.\n\tfloat rsq = dot(uv_fs, uv_fs);\n\tif(rsq >= 1.0) discard;\n\n#if !defined( OBJECT_PICKING_MODE )\n\t// Calculate surface normal in view coordinate system.\n\tvec3 surface_normal = vec3(uv_fs, sqrt(1.0 - rsq));\n\n\t// Compute local surface color.\n\toutputShadedRay(color_fs, surface_normal, vec3(0.0, 0.0, -1.0));\n#else\n    outputFlat(color_fs);\n#endif\n}'},3724:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( OBJECT_PICKING_MODE )\n\nuniform int picking_base_id;\n\nvec4 pickingModeColor(in int primitiveID)\n{\n\t// Compute color from object ID.\n\tint objectID = picking_base_id + primitiveID;\n\n\treturn vec4(\n\t\tfloat(objectID & 0xFF) / 255.0,\n\t\tfloat((objectID >> 8) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 16) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 24) & 0xFF) / 255.0);\n}\n\n#endif\n\nattribute float radius;\n\nvarying vec4 color_fs;\nvarying vec2 uv_fs;\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#elif defined( OBJECT_PICKING_MODE )\n    color_fs = pickingModeColor(gl_VertexID / 4);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    // The index of the quad corner.\n    int corner = gl_VertexID % 4;\n\n    vec2 dir;\n    if(corner == 0) dir = vec2(-1, -1);\n    else if(corner == 1) dir = vec2(1, -1);\n    else if(corner == 2) dir = vec2(1, 1);\n    else dir = vec2(-1, 1);\n    uv_fs = dir;\n\n    // Transform particle center to view space.\n\tvec3 eye_position = (modelViewMatrix * vec4(position, 1.0)).xyz;\n\n    // Apply additional scaling due to model-view transformation to particle radius.\n    float viewspace_radius = radius * length(modelViewMatrix[0]);\n\n\t// Project corner vertex.\n    gl_Position = projectionMatrix * (vec4(eye_position, 1.0) + vec4(dir * viewspace_radius, 0.0, 0.0));\n}'},5636:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n\nvarying vec4 color_fs;\nvarying vec2 uv_fs;\n\nvoid main()\n{\n\t// Calculate distance from the circle\'s center.\n\tfloat rsq = dot(uv_fs, uv_fs);\n\tfloat r = sqrt(rsq);\n\n\t// For antialiasing, calculate alpha value close to the edge of the circle.\n\tfloat afwidth = fwidth(r);\n\tfloat edge = smoothstep(1.0 - afwidth, 1.0, r);\n\tfloat alpha = 1.0 - edge;\n\n\tif(rsq >= 1.0) discard;\n\n#if !defined( OBJECT_PICKING_MODE )\n\t// Calculate surface normal in view coordinate system.\n\tvec3 surface_normal = vec3(uv_fs, sqrt(1.0 - rsq));\n\n\t// Compute local surface color.\n\toutputShadedRay(vec4(color_fs.rgb, color_fs.a * alpha), surface_normal, vec3(0.0, 0.0, -1.0));\n#else\n    outputFlat(color_fs);\n#endif\n}'},8338:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nvarying vec4 color_fs;\nvarying vec3 particle_view_pos_fs;\nvarying float radius_squared;\n\nvoid main()\n{\n    vec3 ray_dir_norm = raycasting_fragment();\n    vec3 sphere_dir = particle_view_pos_fs - ray_origin;\n\n    // Perform ray-sphere intersection test.\n    float b = dot(ray_dir_norm, sphere_dir);\n    vec3 delta = ray_dir_norm * b - sphere_dir;\n    float x = dot(delta, delta);\n    float disc = radius_squared - x;\n\n    if(disc < 0.0)\n        discard; // Ray missed sphere entirely, discard fragment\n\n    // Calculate closest intersection position.\n    float tnear = b - sqrt(disc);\n\n    // Calculate intersection point in view coordinate system.\n    vec3 view_intersection_pnt = ray_origin + tnear * ray_dir_norm;\n\n    // Output the ray-sphere intersection point as the fragment depth\n    // rather than the depth of the bounding box polygons.\n    // The eye coordinate Z value must be transformed to normalized device\n    // coordinates before being assigned as the final fragment depth.\n    vec4 projected_intersection = projectionMatrix * vec4(view_intersection_pnt, 1.0);\n    float zdepth = (projected_intersection.z / projected_intersection.w + 1.0) * 0.5;\n\n#if !defined( OBJECT_PICKING_MODE )\n    // Calculate surface normal in view coordinate system.\n    vec3 surface_normal = normalize(view_intersection_pnt - particle_view_pos_fs);\n    outputShadedRayAndDepth(color_fs, surface_normal, ray_dir_norm, zdepth);\n#else\n    outputFlatAndDepth(color_fs, zdepth);\n#endif\n}'},9689:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment.\nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix);\n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( OBJECT_PICKING_MODE )\n\nuniform int picking_base_id;\n\nvec4 pickingModeColor(in int primitiveID)\n{\n\t// Compute color from object ID.\n\tint objectID = picking_base_id + primitiveID;\n\n\treturn vec4(\n\t\tfloat(objectID & 0xFF) / 255.0,\n\t\tfloat((objectID >> 8) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 16) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 24) & 0xFF) / 255.0);\n}\n\n#endif\n\nattribute float radius;\n\nvarying vec4 color_fs;\nvarying vec3 particle_view_pos_fs;\nvarying float radius_squared;\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#elif defined( OBJECT_PICKING_MODE )\n    color_fs = pickingModeColor(gl_VertexID / 4);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    particle_view_pos_fs = (modelViewMatrix * vec4(position, 1.0)).xyz;\n    float particle_radius = radius * length(modelViewMatrix[0]);\n    radius_squared = particle_radius * particle_radius;\n\n    vec3 uv;\n    int corner = gl_VertexID % 4;\n    if(!isOrthographic) {\n        // Calculate maximum projection of particle:\n        vec3 sphere_dir = particle_view_pos_fs;\n        float sphere_dist_sq = dot(sphere_dir, sphere_dir);\n        float sphere_dist = sqrt(sphere_dist_sq);\n        float tangent_dist = sqrt(sphere_dist_sq - radius_squared);\n        float alpha = acos(tangent_dist / sphere_dist);\n        vec3 dir = cross(sphere_dir, vec3(0.0, 1.0, 0.0));\n\n        float scaling = sphere_dist * tan(alpha) * sqrt(2.0);\n        if(corner == 0) uv = scaling * normalize(dir);\n        else if(corner == 1) uv = scaling * normalize(cross(dir, sphere_dir));\n        else if(corner == 2) uv = -scaling * normalize(dir);\n        else uv = -scaling * normalize(cross(dir, sphere_dir));\n    }\n    else {\n        float scaling = particle_radius * sqrt(2.0);\n        if(corner == 0) uv = vec3(scaling, 0.0, 0.0);\n        else if(corner == 1) uv = vec3(0.0,  scaling, 0.0);\n        else if(corner == 2) uv = vec3(-scaling, 0.0, 0.0);\n        else uv = vec3(0.0, -scaling, 0.0);\n    }\n\n    gl_Position = projectionMatrix * vec4(particle_view_pos_fs + uv, 1.0);\n\n    raycasting_vertex();\n}'},3268:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nvarying vec4 color_fs;\nvarying vec3 particle_view_pos_fs;\nvarying float radius_squared;\n\nvoid main()\n{\n    vec3 ray_dir_norm = raycasting_fragment();\n    vec3 sphere_dir = particle_view_pos_fs - ray_origin;\n\n    // Perform ray-sphere intersection test.\n    float b = dot(ray_dir_norm, sphere_dir);\n    vec3 delta = ray_dir_norm * b - sphere_dir;\n    float x = dot(delta, delta);\n    float disc = radius_squared - x;\n\n\tfloat afwidth = fwidth(disc);\n\tfloat alpha = smoothstep(0.0, afwidth, disc);\n    if(disc <= 0.0)\n        discard; // Ray missed sphere entirely, discard fragment\n\n    // Calculate closest intersection position.\n    float tnear = b - sqrt(disc);\n\n    // Calculate intersection point in view coordinate system.\n    vec3 view_intersection_pnt = ray_origin + tnear * ray_dir_norm;\n\n    // Output the ray-sphere intersection point as the fragment depth\n    // rather than the depth of the bounding box polygons.\n    // The eye coordinate Z value must be transformed to normalized device\n    // coordinates before being assigned as the final fragment depth.\n    vec4 projected_intersection = projectionMatrix * vec4(view_intersection_pnt, 1.0);\n    float zdepth = (projected_intersection.z / projected_intersection.w + 1.0) * 0.5;\n\n#if !defined( OBJECT_PICKING_MODE )\n    // Calculate surface normal in view coordinate system.\n    vec3 surface_normal = normalize(view_intersection_pnt - particle_view_pos_fs);\n    outputShadedRayAndDepth(vec4(color_fs.rgb, alpha), surface_normal, ray_dir_norm, zdepth);\n#else\n    outputFlatAndDepth(color_fs, zdepth);\n#endif\n}'},798:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n\nvarying vec4 color_fs;\n\nvoid main()\n{\n    outputFlat(color_fs);\n}'},5988:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( OBJECT_PICKING_MODE )\n\nuniform int picking_base_id;\n\nvec4 pickingModeColor(in int primitiveID)\n{\n\t// Compute color from object ID.\n\tint objectID = picking_base_id + primitiveID;\n\n\treturn vec4(\n\t\tfloat(objectID & 0xFF) / 255.0,\n\t\tfloat((objectID >> 8) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 16) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 24) & 0xFF) / 255.0);\n}\n\n#endif\n\nattribute float radius;\n\nvarying vec4 color_fs;\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#elif defined( OBJECT_PICKING_MODE )\n    color_fs = pickingModeColor(gl_VertexID / 4);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    // The index of the quad corner.\n    int corner = gl_VertexID % 4;\n\n    vec2 dir;\n    if(corner == 0) dir = vec2(-1, -1);\n    else if(corner == 1) dir = vec2(1, -1);\n    else if(corner == 2) dir = vec2(1, 1);\n    else dir = vec2(-1, 1);\n\n    // Transform particle center to view space.\n\tvec3 eye_position = (modelViewMatrix * vec4(position, 1.0)).xyz;\n\n    // Apply additional scaling due to model-view transformation to particle radius.\n    float viewspace_radius = radius * length(modelViewMatrix[0]);\n\n\t// Project corner vertex.\n    gl_Position = projectionMatrix * (vec4(eye_position, 1.0) + vec4(dir * viewspace_radius, 0.0, 0.0));\n}'},7098:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvoid outputFlatAndDepth(in vec4 color, in float zdepth)\n{\n    gl_FragColor = color;\n    gl_FragDepth = zdepth;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nvarying vec4 color_fs;\nvarying mat3 view_particle_matrix_fs;\nvarying vec3 particle_view_pos_fs;\nvarying vec2 particle_exponents_fs;\n\nconst int PLANECOUNT = 9;\nconst vec4 planes[PLANECOUNT] = vec4[](\n\tvec4(1.0, 1.0, 0.0, 0.0),\n\tvec4(1.0,-1.0, 0.0, 0.0),\n\tvec4(1.0, 0.0, 1.0, 0.0),\n\tvec4(1.0, 0.0,-1.0, 0.0),\n\tvec4(0.0, 1.0, 1.0, 0.0),\n\tvec4(0.0, 1.0,-1.0, 0.0),\n\tvec4(1.0, 0.0, 0.0, 0.0),\n\tvec4(0.0, 1.0, 0.0, 0.0),\n\tvec4(0.0, 0.0, 1.0, 0.0));\n\nconst float EPSILON = 1.0e-10;\nconst float MIN_VALUE = -1.01;\nconst float MAX_VALUE =  1.01;\nconst float BOUND_HUGE = 2.0e+10;\nconst float DEPTH_TOLERANCE = 1.0e-4; // Minimal intersection depth for a valid intersection.\nconst float ZERO_TOLERANCE = 1.0e-10; // If |x| < ZERO_TOLERANCE, x is regarded to be 0.\nconst int   MAX_ITERATIONS = 20;\n\n/// Intersect a ray with an axis aligned unit box.\nbool intersect_box(in vec3 P, in vec3 D, out float dmin, out float dmax)\n{\n    float tmin = 0.0, tmax = 0.0;\n\n    // Left/right.\n    if(abs(D.x) > EPSILON) {\n        if(D.x > EPSILON) {\n            dmin = (MIN_VALUE - P.x) / D.x;\n            dmax = (MAX_VALUE - P.x) / D.x;\n        }\n        else {\n            dmax = (MIN_VALUE - P.x) / D.x;\n            dmin = (MAX_VALUE - P.x) / D.x;\n        }\n\n        if(dmin > dmax) return false;\n    }\n    else {\n        if((P.x < MIN_VALUE) || (P.x > MAX_VALUE))\n\t\t\treturn false;\n        dmin = -BOUND_HUGE;\n        dmax =  BOUND_HUGE;\n    }\n\n    // Top/bottom.\n    if(abs(D.y) > EPSILON) {\n        if(D.y > EPSILON) {\n            tmin = (MIN_VALUE - P.y) / D.y;\n            tmax = (MAX_VALUE - P.y) / D.y;\n        }\n        else {\n            tmax = (MIN_VALUE - P.y) / D.y;\n            tmin = (MAX_VALUE - P.y) / D.y;\n        }\n\n        if(tmax < dmax) {\n            if(tmin > dmin) {\n                if(tmin > tmax) return false;\n                dmin = tmin;\n            }\n            else {\n                if(dmin > tmax) return false;\n            }\n\n            dmax = tmax;\n        }\n        else {\n            if(tmin > dmin) {\n                if(tmin > dmax) return false;\n                dmin = tmin;\n            }\n        }\n    }\n    else {\n        if((P.y < MIN_VALUE) || (P.y > MAX_VALUE)) {\n            return false;\n        }\n    }\n\n    // Front/back.\n    if(abs(D.z) > EPSILON) {\n        if(D.z > EPSILON) {\n            tmin = (MIN_VALUE - P.z) / D.z;\n            tmax = (MAX_VALUE - P.z) / D.z;\n        }\n        else {\n            tmax = (MIN_VALUE - P.z) / D.z;\n            tmin = (MAX_VALUE - P.z) / D.z;\n        }\n\n        if(tmax < dmax) {\n            if(tmin > dmin) {\n                if(tmin > tmax) return false;\n                dmin = tmin;\n            }\n            else {\n                if(dmin > tmax) return false;\n            }\n\n            dmax = tmax;\n        }\n        else {\n            if(tmin > dmin) {\n                if(tmin > dmax) return false;\n                dmin = tmin;\n            }\n        }\n    }\n    else {\n        if((P.z < MIN_VALUE) || (P.z > MAX_VALUE)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfloat evaluate_g(in float x, in float y, in float e)\n{\n    float g = 0.0;\n\n    if(x > y) {\n        g = 1.0 + pow(y / x, e);\n        if(g != 1.0)\n            g = pow(g, 1.0 / e);\n        g *= x;\n    }\n    else if(y != 0.0) {\n        g = 1.0 + pow(x / y, e);\n        if(g != 1.0)\n            g = pow(g, 1.0 / e);\n        g *= y;\n    }\n\n    return g;\n}\n\n/// Computes the superellipsoid value at the given location.\nfloat evaluate_superellipsoid(in vec3 P)\n{\n    return evaluate_g(evaluate_g(abs(P.x), abs(P.y), particle_exponents_fs.x), abs(P.z), particle_exponents_fs.y) - 1.0;\n}\n\n// Home in on the root of a superquadric using a combination of secant and bisection methods.\n// This routine requires that the sign of the function be different at P0 and P1, it will fail drastically if this isn\'t the case.\nvoid solve_hit1(in float v0, in vec3 tP0, in float v1, in vec3 tP1, out vec3 P)\n{\n    int i;\n    float x, v2, v3;\n    vec3 P0, P1, P2, P3;\n\n    P0 = tP0;\n    P1 = tP1;\n\n    // The sign of v0 and v1 changes between P0 and P1, this means there is an intersection point in there somewhere.\n    for(i = 0; i < MAX_ITERATIONS; i++) {\n        if(abs(v0) < ZERO_TOLERANCE) {\n            // Near point is close enough to an intersection - just use it.\n            P = P0;\n            break;\n        }\n\n        if(abs(v1) < ZERO_TOLERANCE) {\n            // Far point is close enough to an intersection.\n            P = P1;\n            break;\n        }\n\n        // Look at the chord connecting P0 and P1.\n        // Assume a line between the points.\n        x = abs(v0) / abs(v1 - v0);\n        P2 = P1 - P0;\n        P2 = P0 + x * P2;\n        v2 = evaluate_superellipsoid(P2);\n\n        // Look at the midpoint between P0 and P1.\n        P3 = P1 - P0;\n        P3 = P0 + 0.5 * P3;\n        v3 = evaluate_superellipsoid(P3);\n\n        if(v2 * v3 < 0.0) {\n            // We can move both ends.\n            v0 = v2;\n            P0 = P2;\n            v1 = v3;\n            P1 = P3;\n        }\n        else {\n            if(abs(v2) < abs(v3)) {\n                // secant method is doing better.\n                if(v0 * v2 < 0.0) {\n                    v1 = v2;\n                    P1 = P2;\n                }\n                else {\n                    v0 = v2;\n                    P0 = P2;\n                }\n            }\n            else {\n                // bisection method is doing better.\n                if(v0 * v3 < 0.0) {\n                    v1 = v3;\n                    P1 = P3;\n                }\n                else {\n                    v0 = v3;\n                    P0 = P3;\n                }\n            }\n        }\n    }\n\n    if(i == MAX_ITERATIONS) {\n        // The loop never quite closed in on the result - just use the point\n        // closest to zero.  This really shouldn\'t happen since the max number\n        // of iterations is enough to converge with straight bisection.\n        if(abs(v0) < abs(v1)) {\n            P = P0;\n        }\n        else {\n            P = P1;\n        }\n    }\n}\n\n\n/// Try to find the root of a superquadric using Newtons method.\nbool check_hit2(in vec3 P, in vec3 D, in float t0, inout vec3 P0, in float v0, in float t1, out float t, out vec3 Q)\n{\n    int i;\n    float dt0, dt1, v1, deltat, maxdelta;\n\n\tconst float eps = 1.0e-5;\n\n    dt0 = t0;\n    dt1 = t0 + 1.0e-4 * (t1 - t0);\n    maxdelta = t1 - t0;\n\n    for(i = 0; (dt0 < t1) && (i < MAX_ITERATIONS); i++) {\n        vec3 P1 = P + dt1 * D;\n        v1 = evaluate_superellipsoid(P1);\n\n        if(v0 * v1 < 0.0) {\n            // Found a crossing point, go back and use normal root solving.\n            solve_hit1(v0, P0, v1, P1, Q);\n            P0 = Q - P;\n            t = length(P0);\n            return true;\n        }\n        else {\n            if(abs(v1) < eps) {\n                Q = P + dt1 * D;\n                t = dt1;\n                return true;\n            }\n            else {\n                if(((v0 > 0.0) && (v1 > v0)) || ((v0 < 0.0) && (v1 < v0))) {\n                    // We definitely failed.\n                    break;\n                }\n                else {\n                    if(v1 == v0) {\n                        break;\n                    }\n                    else {\n                        deltat = v1 * (dt1 - dt0) / (v1 - v0);\n                    }\n                }\n            }\n        }\n\n        if(abs(deltat) > maxdelta) {\n            break;\n\t\t}\n\n        v0 = v1;\n        dt0 = dt1;\n        dt1 -= deltat;\n    }\n\n    return false;\n}\n\nvoid main()\n{\n    // Calculate ray passing through the fragment (in view space).\n    vec3 ray_dir_norm = raycasting_fragment();\n\n\tvec3 ray_origin_shifted = ray_origin;\n\t// This is to improve numeric precision of intersection calculation:\n\tif(isOrthographic)\n\t\tray_origin_shifted.z = particle_view_pos_fs.z;\n\n    // Transform the ray into the superellipsoid space.\n\tvec3 P = view_particle_matrix_fs * (ray_origin_shifted - particle_view_pos_fs);\n\tvec3 D = view_particle_matrix_fs * ray_dir_norm;\n\tfloat len = length(D);\n\tD /= len;\n\n    // Intersect bounding box.\n\tfloat t1, t2;\n    if(!intersect_box(P, D, t1, t2)) {\n\t\tdiscard;\n\t}\n\n    // Test if superellipsoid lies \'behind\' the ray origin.\n\tif(!isOrthographic) {\n\t\tif(t2 < DEPTH_TOLERANCE)\n\t\t\tdiscard;\n\t\tif(t1 < DEPTH_TOLERANCE)\n\t\t\tt1 = DEPTH_TOLERANCE;\n\t}\n\telse {\n\t\t// When using parallel projection, make sure intersection point is always at t>0 by shifting the ray base point.\n\t\tif(t1 < DEPTH_TOLERANCE) {\n\t\t\tP -= D * (DEPTH_TOLERANCE - t1);\n\t\t\tray_origin_shifted -= ray_dir_norm * ((DEPTH_TOLERANCE - t1) / len);\n\t\t\tt2 += DEPTH_TOLERANCE - t1;\n\t\t\tt1 = DEPTH_TOLERANCE;\n\t\t}\n\t}\n\n\tint cnt = 2;\n    float dists[PLANECOUNT + 2];\n    dists[0] = t1;\n    dists[1] = t2;\n\n    // Intersect ray with planes cutting superellipsoids in pieces.\n\t// Find all the places where the ray intersects the set of\n\t// subdividing planes through the superquadric.  Return the\n\t// number of valid hits (within the bounding box).\n\n    // Since min and max dist are the distance to two of the bounding planes\n    // we are considering, there is a high probablity of missing them due to\n    // round off error. Therefore we adjust min and max.\n    float margin = EPSILON * (t2 - t1);\n    float mindist = t1 - margin;\n    float maxdist = t2 + margin;\n\n    // Check the sets of planes that cut apart the superquadric.\n\tint i;\n    for(i = 0; i < PLANECOUNT; i++) {\n        float d = dot(D, planes[i].xyz);\n\n        if(abs(d) < EPSILON)\n            continue; // Can\'t possibly get a hit for this combination of ray and plane.\n\n        float t = (planes[i].w - dot(P, planes[i].xyz)) / d;\n\n        if((t >= mindist) && (t <= maxdist)) {\n            dists[cnt++] = t;\n        }\n    }\n\n    // Sort the results for further processing.\n\t// Todo: Replace this bubble sort implemention with something more efficient.\n\tbool done;\n\tdo {\n\t\tdone = true;\n\t\tfor(i = 1; i < cnt; i++) {\n\t\t\tif(dists[i] < dists[i-1]) {\n\t\t\t\tfloat temp = dists[i];\n\t\t\t\tdists[i] = dists[i-1];\n\t\t\t\tdists[i-1] = temp;\n\t\t\t\tdone = false;\n\t\t\t}\n\t\t}\n\t}\n\twhile(!done);\n\n\tvec3 P0 = P + dists[0] * D;\n\tfloat v0 = evaluate_superellipsoid(P0);\n\n\tfloat tnear = BOUND_HUGE;\n\tif(abs(v0) < ZERO_TOLERANCE) {\n\t\ttnear = dists[0] / len;\n\t}\n\telse {\n\t\tfor(i = 1; i < cnt; i++) {\n\t\t\tvec3 P1 = P + dists[i] * D;\n\t\t\tfloat v1 = evaluate_superellipsoid(P1);\n\n\t\t\tif(abs(v1) < ZERO_TOLERANCE) {\n\t\t\t\ttnear = dists[i] / len;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(v0 * v1 < 0.0) {\n\t\t\t\t\t// Opposite signs: there must be a root between.\n\t\t\t\t\tvec3 P2;\n\t\t\t\t\tsolve_hit1(v0, P0, v1, P1, P2);\n\n\t\t\t\t\tvec3 P3 = P2 - P;\n\t\t\t\t\tfloat t = length(P3);\n\n\t\t\t\t\ttnear = t / len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Although there was no sign change, we may actually be approaching\n\t\t\t\t\t// the surface. In this case, we are being fooled by the shape of the\n\t\t\t\t\t// surface into thinking there isn\'t a root between sample points.\n\t\t\t\t\tfloat t;\n\t\t\t\t\tvec3 P2;\n\t\t\t\t\tif(check_hit2(P, D, dists[i-1], P0, v0, dists[i], t, P2)) {\n\t\t\t\t\t\ttnear = t / len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tv0 = v1;\n\t\t\tP0 = P1;\n\t\t}\n\t}\n\n\t// Discard intersections behind the view point.\n\tif(tnear == BOUND_HUGE || tnear < 0.0) {\n\t\tdiscard;\n\t}\n\n\t// Calculate intersection point in view coordinate system.\n\tvec3 view_intersection_pnt = ray_origin_shifted + tnear * ray_dir_norm;\n\n\t// Output the ray-sphere intersection point as the fragment depth\n\t// rather than the depth of the bounding box polygons.\n\t// The eye coordinate Z value must be transformed to normalized device\n\t// coordinates before being assigned as the final fragment depth.\n\tvec4 projected_intersection = projectionMatrix * vec4(view_intersection_pnt, 1.0);\n\tfloat zdepth = (projected_intersection.z / projected_intersection.w + 1.0) * 0.5;\n\n#if !defined( OBJECT_PICKING_MODE )\n\t// Intersection point in the superellipsoid space.\n\tP += D * (tnear * len);\n\n\t// Calculate surface normal in superellipsoid space.\n\tfloat r, z2n = 0.0;\n\tif(P.z != 0.0) {\n\t\tz2n = pow(abs(P.z), particle_exponents_fs.y);\n\t\tP.z = z2n / P.z;\n\t}\n\n\tif(abs(P.x) > abs(P.y)) {\n\t\tr = pow(abs(P.y / P.x), particle_exponents_fs.x);\n\t\tP.x = (1.0 - z2n) / P.x;\n\t\tP.y = (P.y != 0.0) ? (1.0 - z2n) * r / P.y : 0.0;\n\t}\n\telse if(P.y != 0.0) {\n\t\tr = pow(abs(P.x / P.y), particle_exponents_fs.x);\n\t\tP.x = (P.x != 0.0) ? (1.0 - z2n) * r / P.x : 0.0;\n\t\tP.y = (1.0 - z2n) / P.y;\n\t}\n\n\tif(P.z != 0.0)\n\t\tP.z *= (1.0 + r);\n\n\t// Transform the normal from superellipsoid space to view space.\n\tvec3 surface_normal = normalize(P * view_particle_matrix_fs);\n\n    outputShadedRayAndDepth(color_fs, surface_normal, ray_dir_norm, zdepth);\n#else\n    outputFlatAndDepth(color_fs, zdepth);\n#endif\n}\n'},538:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment.\nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix);\n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2024 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( OBJECT_PICKING_MODE )\n\nuniform int picking_base_id;\n\nvec4 pickingModeColor(in int primitiveID)\n{\n\t// Compute color from object ID.\n\tint objectID = picking_base_id + primitiveID;\n\n\treturn vec4(\n\t\tfloat(objectID & 0xFF) / 255.0,\n\t\tfloat((objectID >> 8) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 16) & 0xFF) / 255.0,\n\t\tfloat((objectID >> 24) & 0xFF) / 255.0);\n}\n\n#endif\n\nattribute mat4 shape_orientation;\nattribute vec2 roundness;\n\nvarying vec4 color_fs;\nvarying mat3 view_particle_matrix_fs;\nvarying vec3 particle_view_pos_fs;\nvarying vec2 particle_exponents_fs;\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#elif defined( OBJECT_PICKING_MODE )\n    color_fs = pickingModeColor(gl_VertexID / 24);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    // Pass ellipsoid matrix and center position to fragment shader.\n\tparticle_view_pos_fs = (modelViewMatrix * shape_orientation[3]).xyz;\n    view_particle_matrix_fs = inverse(mat3(modelViewMatrix) * mat3(shape_orientation));\n\n\t// The x-component of the input vector is exponent \'e\', the y-component is \'n\'.\n\tparticle_exponents_fs.x = 2.0 / (roundness.x > 0.0 ? roundness.x : 1.0);\n\tparticle_exponents_fs.y = 2.0 / (roundness.y > 0.0 ? roundness.y : 1.0);\n\n    raycasting_vertex();\n}'},4147:e=>{"use strict";e.exports={version:"0.1.5"}}}]);